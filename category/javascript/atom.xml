<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | The Sweet Spot]]></title>
  <link href="http://www.g9labs.com/category/javascript/atom.xml" rel="self"/>
  <link href="http://www.g9labs.com/"/>
  <updated>2015-04-30T13:28:59-07:00</updated>
  <id>http://www.g9labs.com/</id>
  <author>
    <name><![CDATA[Andrew Hao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building GPX stats through FRP principles with Bacon.js]]></title>
    <link href="http://www.g9labs.com/2015/04/30/building-gpx-stats-through-frp-principles-on-bacon-dot-js/"/>
    <updated>2015-04-30T12:54:00-07:00</updated>
    <id>http://www.g9labs.com/2015/04/30/building-gpx-stats-through-frp-principles-on-bacon-dot-js</id>
    <content type="html"><![CDATA[<p>With my current fascination with <a href="http://github.com/andrewhao/stressfactor">tracking workouts and location-based-activities</a>, I have been interested in how I might be able to rewrite some of my stats logic with FRP principles.</p>

<h3>What is FRP?</h3>

<p>FRP, or Functional Reactive Programming, is often defined as &ldquo;functional programming over values that change over time&rdquo;. It uses functional composition for streams of data that may appear in an infinite stream of data for some far indeterminate future &ndash; these types of use cases are served well by FRP which <a href="http://en.wikipedia.org/wiki/Functional_reactive_programming">&ldquo;(simplifies) these problems by explicitly modeling time&rdquo;</a>.</p>

<h3>GPS &ndash; your location, varied over time.</h3>

<p>A great application of this would be a workout. Let&rsquo;s say I wanted to build an app that received realtime updates on a person&rsquo;s position. Say the app was a Node server that received this JSON blob from a web API as a location update:</p>

<p><code>json
{ 'lat': 29.192414,
  'lon': 148.113241,
  'ele': 122.1,
  'time': '2015-04-18T13:54:56Z' }
</code></p>

<p>Say that some time later, the API receives this JSON blob:</p>

<p><code>json
{ 'lat': 29.192424,
  'lon': 148.113251,
  'ele': 123.1,
  'time': '2015-04-18T13:55:26Z' }
</code></p>

<p>So we have these data points, that the user has moved <code>+0.00001</code> latitude points and <code>+0.00001</code> longitude points, climbing a total of <code>+1.0</code> meters, over a period of <code>30</code> seconds.</p>

<h4>Exercise: Get my instantaneous velocity</h4>

<p>If we performed this imperatively, we would write it something like this:</p>

<p><code>javascript
var locations = [{ /*json*/ }, { /*json*/ } /*, ...*/];
var last = locations[locations.length-1];
var secondToLast = locations[locations.length-2];
var timeDelta = last.time - secondToLast.time;
var distanceDelta = getDistance(last.lon, last.lat, secondToLast.lon, secondToLast.lat);
var velocity = distanceDelta / timeDelta;
console.log(velocity);
</code></p>

<p>With FRP, it might look more like this:</p>

<p>```javascript
var locationStream = [{ /<em>json</em>/ }, { /<em>json</em>/ } /<em>, &hellip;some JSON objects that might appear in the future </em>/];
locationStream.slidingWindow(2)</p>

<pre><code>          .map(function(pairs) {
            var timeDelta = pairs[1].time - pairs[0].time;
            var distanceDelta = getDistance(pairs[1].lon, pairs[1].lat, pairs[0].lon, pairs[0].lat);
            return distanceDelta / timeDelta
          })
          .onValue(function(velocity) {
            console.log(velocity);
          });
</code></pre>

<p>```</p>

<p>There is a key difference that is not easily demonstrated here &ndash; that the former imperative example requires that all JSON arrays be materialized at once &ndash; via db query, in-memory store, etc. It doesn&rsquo;t account for change in time.</p>

<p>However, the latter functional example accounts for changing values of time as they appear over the stream &ndash; as soon as a new value shows up in the stream, the velocity is changed instantly.</p>

<h3>Some more location-based experiments: rxlocation</h3>

<p>I wrote up a library to parse various facts from a changing stream of GPS events, from instantaneous velocity, average velocity, moving/stopped status, etc.</p>

<p>I investigated different reactive frameworks, mainly <a href="https://github.com/Reactive-Extensions/RxJS/">RxJS</a> and <a href="https://github.com/baconjs/bacon.js/">Bacon.js</a>. My takeaways were that RxJS does everything and the kitchen sink, but I got lost trying to reconcile Node streams with RxJS cold streams. Bacon.js just seemed to work for me, out of the box. I&rsquo;m still learning, so I hope to have a better understanding of the core issues here.</p>

<p>You can check it out here: <a href="https://github.com/andrewhao/rxlocation">rxlocation</a>.</p>
]]></content>
  </entry>
  
</feed>
