<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember app kit | The Sweet Spot]]></title>
  <link href="http://www.g9labs.com/category/ember-app-kit/atom.xml" rel="self"/>
  <link href="http://www.g9labs.com/"/>
  <updated>2018-08-29T22:55:55-07:00</updated>
  <id>http://www.g9labs.com/</id>
  <author>
    <name><![CDATA[Andrew Hao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Moving to Ember App Kit]]></title>
    <link href="http://www.g9labs.com/2014/01/26/moving-to-ember-app-kit/"/>
    <updated>2014-01-26T23:32:00-08:00</updated>
    <id>http://www.g9labs.com/2014/01/26/moving-to-ember-app-kit</id>
    <content type="html"><![CDATA[<p>I’ve noticed a bit of the buzz around <a href="https://github.com/stefanpenner/ember-app-kit">Ember App Kit</a><br />
recently and decided to move Hendrix, my music management app, over from<br />
a <a href="http://yeoman.io/">Yeoman</a>-generated Ember app to EAK with all its<br />
bells and whistles.</p>

<h3 id="whats-the-difference">What’s the difference?</h3>

<p>Well on the surface, the two frameworks aren’t very different. The<br />
standard Yeoman build tool sets you up with Grunt and Bower, which is<br />
what EAK provides you out of the box. The cool stuff happens when you<br />
dive under the hood: ES6 module transpilation and an AMD-compatible<br />
Ember Resolver, built-in Karma integration and a built-in API stub<br />
framework for development and test environments.</p>

<h3 id="the-joys-of-modules">The joys of modules</h3>

<p>What I didn’t realize was that compiling to ES6 modules required that my<br />
filenames be renamed exactly how the modules were going to be placed,<br />
with the extra caveat that resource actions needed to live in their own<br />
directories. Recall that in the old way of doing things with globals and<br />
namespaces, you could get away with throwing a route file like this in<br />
your app directory:</p>

<pre><code>routes/
  songs_index_controller.js
</code></pre>

<p>And inside:</p>

<div class="language-javascript highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>MyApp.SongsIndexRoute = Ember.Route.extend({
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  <span style="color:#777">//...</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
</pre></div>
</div>
</div>

<p>In EAK’s world, you need to nest the file under the <code>songs/</code> directory,<br />
and strip the type from the filename, like so:</p>

<pre><code>routes/
  songs/
    index.js
</code></pre>

<p>Inside the file, you assign the function to a variable and let it be<br />
exported in the default namespace.</p>

<div class="language-javascript highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> SongsIndexRoute = Ember.Route.extend({
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  <span style="color:#777">//...</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
<span class="line-numbers"><a href="#n4" name="n4">4</a></span><span style="color:#080;font-weight:bold">export</span> <span style="color:#080;font-weight:bold">default</span> SongsIndexRoute;
</pre></div>
</div>
</div>

<h3 id="file-name-matters">File name matters</h3>

<p>The <a href="https://github.com/stefanpenner/ember-jj-abrams-resolver/">new Ember resolver</a> <br />
loads modules in a smart way – according to how the framework<br />
structures resources, controllers and their corresponding actions. So<br />
visiting <code>#/songs</code> from my app caused the app to look up and load<br />
<code>appkit/routes/songs/index</code>. What I didn’t realize was <em>this module must<br />
live at a very specific place in the file directory structure</em>.<br />
I realized that I left the module type in the file name the first time<br />
around, like this:</p>

<pre><code>routes/
  songs/
    index_route.js
</code></pre>

<p>There are no types in the module names – or the filenames, for that<br />
matter. I had not realized this (I’m also an AMD newbie) – so I had<br />
left my files un-renamed as <code>songs_index_route</code>, which meant that<br />
the module loader had stored the SongsIndexRoute module under<br />
<code>appkit/routes/songs/index_route</code>, but was doing a route lookup through<br />
the Resolver for: <code>appkit/routes/songs/index</code>. Renaming the file to:</p>

<pre><code>routes/
  songs/
    index.js
</code></pre>

<p>did the trick.</p>
]]></content>
  </entry>
  
</feed>
