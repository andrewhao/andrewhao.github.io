<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | The Sweet Spot]]></title>
  <link href="http://www.g9labs.com/category/rails/atom.xml" rel="self"/>
  <link href="http://www.g9labs.com/"/>
  <updated>2018-03-21T20:47:56-07:00</updated>
  <id>http://www.g9labs.com/</id>
  <author>
    <name><![CDATA[Andrew Hao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pitfalls to avoid when moving to async systems]]></title>
    <link href="http://www.g9labs.com/2017/07/19/pitfalls-to-avoid-when-moving-to-async-systems/"/>
    <updated>2017-07-19T19:57:18-07:00</updated>
    <id>http://www.g9labs.com/2017/07/19/pitfalls-to-avoid-when-moving-to-async-systems</id>
    <content type="html"><![CDATA[<p>I recently published a post on the <a href="http://blog.carbonfive.com">Carbon Five blog</a> titled <a href="http://blog.carbonfive.com/2017/07/18/evented-rails-decoupling-complex-domains-in-rails-with-domain-events/">“Evented Rails: Decoupling complex domains in Rails with Domain Events”</a> that takes some of my thoughts about moving a Rails app to use Domain Events - leveraging the power of Sidekiq (or your job runner of choice) to send async messages between different domains of your app.</p>

<p>This approach always seems nice from the outset, but can hide some painful complexities if you go too far down the rabbit hole. Here is a repost of the latter half of that article, which is worth repeating:</p>

<h2 id="big-wins-of-the-async-model-speed--scalability">Big win[s of the async model]: speed &amp; scalability</h2>

<p>By splitting out domain logic into cohesive units, we’ve just designed our systems to farm out their workloads to a greater scalable number of workers. Imagine if you had a web request thread that would take 500ms to return, but 150ms of that time was spent doing a round trip to a different service. By decoupling that work from the main request thread and moving it to a background job – we’ve just sped up the responsiveness of our system for our end user, and we know that studies have shown that page speed performance equals money.</p>

<p>Additionally, making our application calls asynchronous allows us to scale the number of processing power we allocate to our system. We now have the ability to horizontally scale workers according to the type of job, or the domain they are working from. This may result in cost and efficiency savings as we match processing power to the workload at hand.</p>

<h2 id="big-challenge-dealing-with-asynchronous-data-flows">Big challenge: dealing with asynchronous data flows</h2>

<p>Once things go async, we now have a fundamentally different data design. For example, say you implemented an HTTP API endpoint that performed some action in the system synchronously. However, now you’ve farmed out the effects of the action to background processes through domain events. While this is great for response times, you’ve now no longer got the guarantees to the caller that the desired side effect has been performed once the server responds back.</p>

<h3 id="asynchronous-polling">Asynchronous polling</h3>

<p>An option is to implement the Polling pattern. The API can return a request identifier back to the caller on first call, with which which the caller can now query the API for the result status. If the result is not ready, the API service will return with a Nack message, or negative Ack, implying that the result data has not arrived yet. As soon as the results in the HTTP API are ready, the API will correctly return the result.</p>

<h3 id="pubsub-all-the-way-down">Pub/Sub all the way down</h3>

<p>Another option is to embrace the asynchronous nature of the system wholly and transition the APIs to event-driven, message-based systems instead. In this paradigm, we would introduce an external message broker such as RabbitMQ to facilitate messages within our systems. Instead of providing an HTTP endpoint to perform an action, the API service could subscribe to a domain event from the calling system, perform its side effect, then fire off its own domain event, to which the calling system would subscribe to. The advantage of this approach is that this scheme makes more efficient use of the network (reducing chattiness), but we trade off the advantages of using HTTP (the ubiquity of the protocol, performance enhancements like layered caching).</p>

<p>Browser-based clients can also get in on the asynchronous fun with the use of WebSockets to subscribe to server events. Instead of having a browser call an HTTP API, the browser could simply fire a WebSocket event, to which the service would asynchronously process (potentially also proxying the message downstream to other APIs with messages) and then responding via a WebSocket message when the data is done processing.</p>

<h2 id="big-challenge-data-consistency">Big challenge: data consistency</h2>

<p>When we choose an asynchronous evented approach, we now have to consider how to model asynchronous transactions. Imagine that one domain process charges a user’s credit card with a third party payment processor and another domain process is responsible for updating it in your database. There are now two processes updating two data stores. A central tenet in distributed systems design is to anticipate and expect failure. Let’s imagine any of the following scenarios happens:</p>

<ol>
  <li>An Amazon AWS partial outage takes down one of your services but not the other.</li>
  <li>One of your services becomes backed up due to high traffic, and no longer can service new requests in a timely manner.</li>
  <li>A new deployment has introduced a data bug in a downstream API that your teams are rushing to fix, but will requiring manual reconciling with the data in the upstream system.</li>
</ol>

<p>How will you build your domain and data models to account for failures in each processing step? What would happen if you have one operation occur in one domain that depends on data that has not yet appeared in another part of the system? Can you design your data models (and database schema) to support independent updates without any dependencies? How will you handle the case when one domain action fails and the other completes?</p>

<h3 id="first-approach-avoid-it-by-choosing-noncritical-paths-to-decouple-first">First approach: avoid it by choosing noncritical paths to decouple, first</h3>

<p>If you are implementing an asynchronous, evented paradigm for the first time, I suggest you carefully begin decoupling boundaries with domain events only for events that lie outside the critical business domain path. Begin with some noncritical aspect of the system — for example, you may have a third party analytics tracking service that you must publish certain business events to. That would be a nice candidate to decouple from the main request process and move to an async path.</p>

<h3 id="second-approach-enforce-transactional-consistency-within-the-same-processdomain-boundary">Second approach: enforce transactional consistency within the same process/domain boundary</h3>

<p>Although we won’t discuss specifics in this article, if you must enforce transactional consistency in some part of your system (say, the charging of a credit card with the crediting of money to a user’s account) then I suggest that you perform those operations within the same bounded context and same process, leaning on transactional consistency guarantees provided by your database layer.</p>

<h3 id="third-approach-embrace-it-with-eventual-consistency">Third approach: embrace it with eventual consistency</h3>

<p>Alternatively, you may be able to lean on “eventual consistency” semantics with your data. Maybe it’s less important that your data squares away with itself immediately — maybe it’s more important that the data, at some guaranteed point in time — eventually lines up. It may be OK for some aspect of your data (e.g. notifications in a news feed) and may not be appropriate for other data (e.g. a bank account balance).</p>

<p>You may need to fortify your system to ensure that data eventually becomes consistent. This may involve building out the following pieces of infrastructure.</p>

<ol>
  <li>Messages need to be durable — make sure your job enqueuing system does not drop messages, or at least has a failure mode to re-process them when (not if!) your system fails.</li>
  <li>Your jobs should be designed to be idempotent, so they can be retried multiple times and result in the correct outcome.</li>
  <li>You should easily be able to recover from bad data scenarios. Should a service go down, it should be able to replay messages, logs, or the consumer should have a queue of retry-able messages it can send.</li>
  <li>Eventual consistency means that you may need an external process to verify consistency. You may be doing this sort of verification process in a data warehouse, or in a different software system that has a full view of all the data in your distributed system. Be sure that this sort of verification is able to reveal to you holes in the data, and provide actionable insights so you can fix them.</li>
  <li>You will need to add monitoring and logging to measure the failure modes of the system. When errors spike, or messages fail to send (events fail to fire), you need to be alerted. Once alerted, your logging must be good enough to be able to trace the source and the data that each request is firing.</li>
</ol>

<p>The scale of this subject is large and is under active research in the field of computer science. A good book to pick up that discusses this topic is <a href="https://www.amazon.com/Service-Oriented-Design-Rails-Addison-Wesley-Professional/dp/0321659368">Service-Oriented Design with Ruby on Rails</a>. The popular <a href="http://www.enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a> book also has a great topic on consistency (and is accompanied by a very helpful <a href="http://www.enterpriseintegrationpatterns.com/patterns/conversation/EnsuringConsistencyIntro.html">online guide</a> as well).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails, meet Phoenix: Migrating to Phoenix with Rails session sharing]]></title>
    <link href="http://www.g9labs.com/2016/06/24/migrating-to-phoenix-with-rails-session-sharing/"/>
    <updated>2016-06-24T13:31:06-07:00</updated>
    <id>http://www.g9labs.com/2016/06/24/migrating-to-phoenix-with-rails-session-sharing</id>
    <content type="html"><![CDATA[<p>You’ve resolved to build your company’s Next Big Thing in Phoenix and Elixir. That’s great! You’re facing a problem though - all user authentication and access concerns are performed on your Rails system, and the work to reimplement this in Phoenix is significant.</p>

<p>Fortunately for you, there is a great Phoenix plug to share session data between Rails and Phoenix. If you pull this off, you’ll be able to build your new API on your Phoenix app, all while letting Rails handle user authentication and session management.</p>

<h3 id="before-we-begin">Before we begin</h3>
<p>In this scenario, you want to build out a new API in Phoenix that is consumed by your frontend single-page application, whose sessions are hosted on Rails. We’ll call the Rails app <code>rails_app</code> and your new Phoenix app <code>phoenix_app</code>.</p>

<p>Additionally, each app will use a different subdomain. The Rails app will be deployed at the <code>www.myapp.com</code> subdomain. The Phoenix app will be deployed at the <code>api.myapp.com</code> subdomain.</p>

<p>We are going to take <a href="https://github.com/cconstantin">Chris Constantin</a>’s excellent <a href="https://github.com/cconstantin/plug_rails_cookie_session_store"><code>PlugRailsCookieSessionStore</code></a> plug and integrate it into our Phoenix project. Both apps will be configured with identical cookie domains, encryption salts, signing salts, and security tokens.</p>

<p>In the examples that follow, I’ll be using the latest versions of each framework at the time of writing, Rails 4.2 and Phoenix 1.2.</p>

<h3 id="cookie-based-session-storage">Cookie-based session storage</h3>

<p>Our session data is stored on the client in a secure, encrypted, validated cookie. We won’t cover the basics of cookies here, but <a href="http://www.justinweiss.com/articles/how-rails-sessions-work/">you can read more about them here</a>.</p>

<p>Our approach will only work if your current Rails system utilizes cookie-based sessions. We will not cover the use case with a database-backed session store in SQL, Redis, or Memcache.</p>

<h3 id="step-1-configure-rails-accordingly">Step 1: Configure Rails accordingly</h3>

<h4 id="configure-the-cookie-store">Configure the cookie store</h4>

<p>Let’s set up your Rails app to use a JSON cookie storage format:</p>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#777"># config/initializer/session_store.rb</span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span><span style="color:#777"># Use cookie session storage in JSON format. Here, we scope the cookie to the root domain.</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span><span style="color:#036;font-weight:bold">Rails</span>.application.config.session_store <span style="color:#A60">:cookie_store</span>, <span style="color:#606">key</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">_rails_app_session</span><span style="color:#710">'</span></span>, <span style="color:#606">domain</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#069">ENV</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">DOMAIN</span><span style="color:#710">'</span></span>]<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span><span style="color:#036;font-weight:bold">Rails</span>.application.config.action_dispatch.cookies_serializer = <span style="color:#A60">:json</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span><span style="color:#777"># These salts are optional, but it doesn't hurt to explicitly configure them the same between the two apps.</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span><span style="color:#036;font-weight:bold">Rails</span>.application.config.action_dispatch.encrypted_cookie_salt = <span style="color:#069">ENV</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">SESSION_ENCRYPTED_COOKIE_SALT</span><span style="color:#710">'</span></span>]
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span style="color:#036;font-weight:bold">Rails</span>.application.config.action_dispatch.encrypted_signed_cookie_salt = <span style="color:#069">ENV</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</span><span style="color:#710">'</span></span>]
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
</pre></div>
</div>
</div>

<p>Your app may not be configured with a <code>SESSION_ENCRYPTED_COOKIE_SALT</code> and <code>SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</code>. You may generate a pair with any random values.</p>

<p><a href="http://nipperlabs.com/rails-secretkeybase">Some speculate</a> that Rails does not require the two salts by default because the <code>SECRET_KEY_BASE</code> is sufficiently long enough to not require a salt. In our example, we choose to supply them anyways to be explicit.</p>

<p>Another important value to note here is that we have chosen a key for our session cookie - <code>_rails_app_session</code>. This value will be the shared cookie key for both apps.</p>

<h3 id="step-2-configure-the-plug-for-phoenix">Step 2: Configure the plug for Phoenix</h3>

<p>Turning our attention to our Phoenix app, in the <code>mix.exs</code> file, add the library dependency:</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span># mix.exs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>defmodule PhoenixApp
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  defp deps do
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    # snip
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    {:plug_rails_cookie_session_store, &quot;~&gt; 0.1&quot;},
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    # snip
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  end
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>end
</pre></div>
</div>
</div>

<p>Then run <code>mix deps.get</code> to fetch the new library.</p>

<p>Now in your <code>web/phoenix_app/endpoint.ex</code> file, remove the configuration for the existing session store and add the configuration for the Rails session store.</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span># lib/phoenix_app/endpoint.ex
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>defmodule PhoenixApp.Endpoint do
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  plug Plug.Session,
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    # Remove the original cookie store that comes with Phoenix, out of the box.
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    # store: :cookie,
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    # key: &quot;_phoenix_app_key&quot;,
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    # signing_salt: &quot;M8emDP0h&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    store: PlugRailsCookieSessionStore,
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    # Decide on a shared key for your cookie. Oftentimes, this should
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    # mirror your Rails app session key
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    key: &quot;_rails_app_session&quot;,
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    secure: true,
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    encrypt: true,
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    # Specifies the matching rules on the hostname that this cookie will be valid for
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    domain: &quot;.#{System.get_env(&quot;DOMAIN&quot;)}&quot;,
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    signing_salt: System.get_env(&quot;SESSION_ENCRYPTED_SIGNED_COOKIE_SALT&quot;),
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    encryption_salt: System.get_env(&quot;SESSION_ENCRYPTED_COOKIE_SALT&quot;),
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    key_iterations: 1000,
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    key_length: 64,
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    key_digest: :sha,
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    # Specify a JSON serializer to use on the session
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    serializer: Poison
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>end
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>
</pre></div>
</div>
</div>

<p>We set a <code>DOMAIN</code> environment variable with the value<br />
<code>myapp.com</code>. The goal is for these two apps to be able to be deployed at any subdomain that ends in <code>myapp.com</code>, and still be able to share the cookie.</p>

<p>The <code>secure</code> flag configures the app to send a secure cookie, which only is served over SSL HTTPS connections. It is highly recommended for your site; if you haven’t upgraded to SSL, you should do so now!</p>

<p>Our cookies are signed such that their origins are guaranteed to have been computed from our app(s). This is done for free with Rails (and Phoenix’s) session libraries. The signature is derived from the <code>secret_key_base</code> and <code>signing_salt</code>.</p>

<p>The <code>encrypt</code> flag encrypts the contents of the cookie’s value with an encryption key derived from <code>secret_key_base</code> and <code>encryption_salt</code>. This should always be set to <code>true</code>.</p>

<p><code>key_iterations</code>, <code>key_length</code> and <code>key_digest</code> are configurations that dictate how the signing and encryption keys are derived. These are <a href="https://github.com/rails/rails/blob/4-2-stable/railties/lib/rails/application.rb">configured to match Rails’ defaults</a> (see also: <a href="https://github.com/rails/rails/blob/4-2-stable/activesupport/lib/active_support/key_generator.rb">defaults</a>). Unless your Rails app has custom configurations for these values, you should leave them be.</p>

<h3 id="step-3-configure-both-apps-to-read-from-the-new-environment-variables">Step 3: Configure both apps to read from the new environment variables</h3>

<p>Be sure your development and production versions of your app are configured with identical values for <code>DOMAIN</code>, <code>SESSION_ENCRYPTED_COOKIE_SALT</code> and <code>SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</code>. You’ll want to make sure your production apps store identical key-value pairs.</p>

<h3 id="step-4-change-phoenix-controllers-to-verify-sessions-based-on-session-data">Step 4: Change Phoenix controllers to verify sessions based on session data.</h3>

<p>Now when the Phoenix app receives incoming requests, it can simply look up user session data in the session cookie to determine whether the user is logged in, and who that user is.</p>

<p>In this example, our Rails app implements user auth with Devise and Warden. We know that Warden stores the user ID and a segment of the password hash in the <code>warden.user.user.key</code> session variable.</p>

<p>Here’s what the raw session data looks like when the <code>PlugRailsCookieSessionStore</code> extracts it from the cookie:</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>%{&quot;_csrf_token&quot; =&gt; &quot;ELeSt4MBUINKi0STEBpslw3UevGZuVLUx5zGVP5NlQU=&quot;,
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  &quot;session_id&quot; =&gt; &quot;17ec9b696fe76ba4a777d625e57f3521&quot;,
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  &quot;warden.user.user.key&quot; =&gt; [[2], &quot;$2a$10$R/3NKl9KQViQxY8eoMCIp.&quot;]}
</pre></div>
</div>
</div>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>defmodule PhoenixApp.SomeApiResourceController do
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  use PhoenixApp.Web, :controller
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  def index(conn, _params) do
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    {:ok, user_id} = load_user(conn)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    conn
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    |&gt; assign(:user_id, user_id)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    |&gt; render(&quot;index.html&quot;)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  end
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  plug :verify_session
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  # If we've found a user, then allow the request to continue.
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  # Otherwise, halt the request and return a 401
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  defp verify_session(conn, _) do
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    case load_user(conn) do
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      {:ok, user_id} -&gt; conn
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      {:error, _} -&gt; conn |&gt; send_resp(401, &quot;Unauthorized&quot;) |&gt; halt
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    end
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  end
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>  defp load_user(conn) do
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    # =&gt; The Warden user storage scheme: [user_id, password_hash_truncated]
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    # [[1], &quot;$2a$10$vnx35UTTJQURfqbM6srv3e&quot;]
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    warden_key = conn |&gt; get_session(&quot;warden.user.user.key&quot;)
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>    case warden_key do
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>      [[user_id], _] -&gt; {:ok, user_id}
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>      _ -&gt; {:error, :not_found}
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>    end
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>  end
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>end
</pre></div>
</div>
</div>

<p>A very naive plug implementation simply renders a 401 if the session key is not found in the session, otherwise it allows the request through.</p>

<h3 id="step-5-move-session-concerns-into-its-own-module">Step 5: Move session concerns into its own module</h3>

<p>Let’s move session concerns around session parsing out of the controller into its own <code>Session</code> module. Additionally, we include two helpers, <code>current_user/1</code> and <code>logged_in?/1</code>.</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span># web/models/session.ex
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>defmodule PhoenixApp.Session do
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  use PhoenixApp.Web, :controller
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  def current_user(conn) do
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    # Our app's concept of a User is merely whatever is stored in the
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    # Session key. In the future, we could then use this as the delegation
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    # point to fetch more details about the user from a backend store.
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    case load_user(conn) do
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      {:ok, user_id} -&gt; user_id
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      {:error, :not_found} -&gt; nil
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    end
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  end
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  def logged_in?(conn) do
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    !!current_user(conn)
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  end
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  def load_user(conn) do
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    # =&gt; The Warden user storage scheme: [user_id, password_hash_truncated]
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    # [[1], &quot;$2a$10$vnx35UTTJQURfqbM6srv3e&quot;]
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    warden_key = conn |&gt; get_session(&quot;warden.user.user.key&quot;)
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    case warden_key do
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      [[user_id], _] -&gt; {:ok, user_id}
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>      _ -&gt; {:error, :not_found}
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    end
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  end
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>end
</pre></div>
</div>
</div>

<p>This leaves the controller looking skinnier, implementing only the Plug. Extracted methods are delegated to the new <code>Session</code> module.</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>defmodule PhoenixApp.SomeApiResourceController do
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  use PhoenixApp.Web, :controller
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  alias PhoenixApp.Session
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  def index(conn, _params) do
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    IO.inspect conn.private.plug_session
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    user_id = Session.current_user(conn)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    conn
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    |&gt; assign(:user_id, user_id)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    |&gt; render(&quot;index.html&quot;)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  end
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  plug :verify_session
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  # Future refinements could extract this into its own Plug file.
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  defp verify_session(conn, _) do
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    case Session.logged_in?(conn) do
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      false -&gt; conn |&gt; send_resp(401, &quot;Unauthorized&quot;) |&gt; halt
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      _ -&gt; conn
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    end
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  end
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>end
</pre></div>
</div>
</div>

<p>Finally, we implement some nice helpers for your APIs:</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span># web/web.ex
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>def view do
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  quote do
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    # snip
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    import PhoenixApp.Session
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  end
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>end
</pre></div>
</div>
</div>

<p>This gives you the ability to call <code>logged_in?(@conn)</code> and <code>current_user(@conn)</code> from within your views, should you desire to.</p>

<h3 id="step-6-fetching-additional-information-from-the-backend">Step 6: Fetching additional information from the backend</h3>

<p>Let’s enhance our <code>Session</code> module with the capability to fetch additional information from another resource.</p>

<p>In this case, we’ll model a call an external User API to fetch extended data about the User, potentially with some sensitive information (that’s why we didn’t want to serialize it into the session).</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span># web/models/user.ex
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>defmodule PhoenixApp.User do
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  # Gets some user identity information like email, avatar image.
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  # For this example, we'll use a random user generator.
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  #
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  # This example hits an API, but this could just as easily be something that hits
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  # the database, or Redis, or some cache.
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  def fetch(user_id) do
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    %{ body: body } = HTTPotion.get(&quot;https://randomuser.me/api?seed=#{user_id}&quot;)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    [result | _ ] = body |&gt; Poison.decode! |&gt; Map.get(&quot;results&quot;)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    result
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  end
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>end
</pre></div>
</div>
</div>

<p>Now our <code>Session</code> can be extended to return the proper <code>User</code>, which may provide more utility to us as we implement our Phoenix feature.</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>defmodule PhoenixApp.Session do
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  use PhoenixApp.Web, :controller
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  alias PhoenixApp.User
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  def current_user(conn) do
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    case load_user(conn) do
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      # Changed current_user/1 to now return a User or a nil.
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      {:ok, user_id} -&gt; user_id |&gt; User.fetch
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      {:error, :not_found} -&gt; nil
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    end
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  end
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  # snip
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>end
</pre></div>
</div>
</div>

<h4 id="heres-the-two-apps-in-action">Here’s the two apps in action:</h4>

<p><img src="http://i.imgur.com/Vu72x7C.gif" alt="Flipping between the two apps, logged in and out." /></p>

<h3 id="heroku-deployment-gotchas">Heroku deployment gotchas</h3>

<p>If you are deploying this to Heroku with the popular <a href="git@github.com:HashNuke/heroku-buildpack-elixir.git">Heroku Elixir buildpack</a>, please be aware that adding or changing environment variables that are required at build time require that the new environment variables outlined here are added to your <code>elixir_buildpack.config</code> file in your repository.</p>

<div class="language-elixir highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span># elixir_buildpack.config
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>config_vars_to_export=(SECRET_KEY_BASE SESSION_ENCRYPTED_COOKIE_SALT SESSION_ENCRYPTED_SIGNED_COOKIE_SALT DOMAIN)
</pre></div>
</div>
</div>

<h3 id="caveats-and-considerations">Caveats and considerations</h3>

<h4 id="csrf-incompatibilites">CSRF incompatibilites</h4>

<p>At the time of this writing, Phoenix and Rails overwrite each others’ session CSRF tokens with incompatible token schemes. This means that you are not able to make remote POST or PUT requests across the apps with CSRF protection turned on. Our current approach will work best with a read-only API, at the moment.</p>

<h4 id="be-judicious-about-what-you-store-in-a-cookie">Be judicious about what you store in a cookie</h4>

<p>Cookies themselves have their own strengths and drawbacks. We should note that you should be judicious about the amount of <a href="http://guides.rubyonrails.org/security.html#replay-attacks-for-cookiestore-sessions">data you store in a session</a> (hint: only the bare minimum, and nothing sensitive).</p>

<p>The OWASP guidelines also provide some <a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet">general security practices around cookie session storage</a>.</p>

<h4 id="moving-beyond-session-sharing">Moving beyond session sharing</h4>

<p>Even though this scheme may work in the short run, coupling our apps at this level in the long run will result in headaches as the apps are coupled to intricate session implementation details. If, in the long run, you wanted to continue scaling out your Phoenix app ecosystem, you may want to look into the following authentication patterns, both of which move your system toward a microservices architecture.</p>

<p>1) Develop an <a href="http://microservices.io/patterns/apigateway.html">API gateway</a> whose purpose is to be the browser’s buffer to your internal service architecture. This one gateway is responsible for identity access and control, decrypting session data and proxying requests to an umbrella of internal services (which may be Rails or Phoenix). Internal services may receive user identities in unencrypted form.</p>

<p>2) Consider implementing a <a href="https://jwt.io/">JWT token implementation</a> across your apps, in which <a href="https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/">all session and authorization claims are stored in the token itself, and encrypted in the client and server.</a>. This scheme may still rely on cookies (you may store the token in a cookie, or pass it around in an HTTP header). The benefits of this scheme is the ability for your app(s) to manage identity and authentication claims on their own without having to verify against a third party. Drawbacks of this scheme are <a href="http://blog.prevoty.com/does-jwt-put-your-web-app-at-risk">the difficulty around revoking or expiring sessions</a>.</p>

<p>Each of these approaches is not without overhead and complexity; be sure to do your homework before your proceed.</p>

<h3 id="conclusion">Conclusion</h3>

<p>That’s it! I hope I’ve illustrated a quick and easy way to get a working Phoenix app sharing sessions with Rails app(s), should you decide to prototype one in your existing system. I’ve also pushed up a <a href="https://github.com/andrewhao/sample-rails-phoenix-shared-sessions/">sample app if you want to cross-reference the code</a>. Good luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on performance tuning a Puma server]]></title>
    <link href="http://www.g9labs.com/2015/06/29/notes-on-performance-tuning-a-puma-server/"/>
    <updated>2015-06-29T11:47:00-07:00</updated>
    <id>http://www.g9labs.com/2015/06/29/notes-on-performance-tuning-a-puma-server</id>
    <content type="html"><![CDATA[<p>A couple of months ago, I was tuning a Rails app for one of our clients.<br />
This client wanted to know how performant their app would be under load.</p>

<p>To do that, you can do several different things:</p>

<ol>
  <li>Tune the thread/process balance within the VM</li>
  <li>Horizontally scale with your cloud platform.</li>
</ol>

<p>This is a discussion of the former (#1):</p>

<h2 id="set-up-the-test">1) Set up the test</h2>

<h3 id="drive-with-a-synthetic-script">Drive with a synthetic script</h3>

<p>Our application had a synthetic load driver that would run Selenium to<br />
execute various app tasks. This synthetic driver could be parallelized<br />
across many notes via Rainforest QA, Sauce Labs or Browserify.</p>

<p>In our case, I only needed to run our synthetic load script on a single<br />
node in multiple processes, which simulated enough load to anticipate<br />
another order of magnitude of traffic.</p>

<h3 id="know-how-to-inspect-the-server-under-load">Know how to inspect the server under load.</h3>

<p>Commands you will want to know:</p>

<pre><code>$ free -m # Find the total amount of free memory on your machine
$ ps uH p &lt;pid&gt; # List out process threads
$ kill -TTIN &lt;puma_master_pid&gt; # Add a puma worker
$ kill -TTOU &lt;puma_master_pid&gt; # Remove a puma worker
$ kill -USR2 &lt;puma_master_pid&gt; # Kill the puma master &amp; workers
</code></pre>

<h2 id="generating-more-load-use-external-load-testing-services-or-plain-tools">Generating more load: use external load testing services, or plain tools.</h2>

<p>Try using <a href="http://www.flood.io">Flood.io</a> or JMeter for performance load.</p>

<p>I tried looking into the <a href="https://github.com/schneems/puma_auto_tune">puma_auto_tune</a> gem, but it required a higher level of production instrumentation than I was ready to give it.</p>

<h2 id="analysis-new-relic-scalability-analysis">Analysis: New Relic scalability analysis</h2>

<p>New Relic gave us a scalability analysis scatter plot, plotting<br />
throughput against average application response time. In essence, it<br />
allows you to see spikes in response times as correlated to throughput.</p>

<h2 id="process">Process:</h2>

<p>My approach was to use the synthetic script to generate productionlike<br />
node and ramp up the # of load actors in 5m increments. Each run would<br />
test the following Puma process/thread balance:</p>

<p>Run #1: Single-process, multi threads.<br />
Run #2: Multiple processes, single threaded.<br />
Run #3: Multiple processes, multiple threads.</p>

<blockquote>
  <h3 id="aside-how-many-of-these-threadsprocesses-should-i-be-using">Aside: <em>how many</em> of these threads/processes should I be using?</h3>

  <p>Note that your numbers will be different on the execution<br />
characteristics of your app and your server environment. Tweak it for<br />
yourself. You’re designing an experiment.</p>

  <p>If you’re curious, our Rails app started out with 4 threads on 2<br />
workers. We made the # of Puma workers (both min and max) environment<br />
variables so we could tweak the variables easily without deploying.</p>
</blockquote>

<p>The strategy was then to look at the perf characteristics of each run in<br />
the scatter plot. If there were any spikes in the graph with the<br />
increase of load, then that would be noted. Even minor features like an<br />
increase in slope would be noted - at that point, the incremental cost<br />
of each request increases with overall system load.</p>

<h2 id="results">Results</h2>

<p>I don’t have the New Relic data on hand to show, now, but in our case we<br />
discovered two things:</p>

<ol>
  <li>The server easily scaled from ~10 -&gt; ~500 rpm with a virtually flat<br />
line for all runs.</li>
  <li>The app exhibited no noticeable performance differences when flipped<br />
between uniprocess-multithreaded, multiprocess-unithreaded, and<br />
multiprocess-multithreaded modes. Any performance gains were under a<br />
tolerable threshold.</li>
</ol>

<p>How do we parse these results?</p>

<ul>
  <li>We note that we didn’t really push the performance threshold on this<br />
app (it’s not meant to be a public web site and 95% of it is behind a<br />
login wall to a specialized group of users). Thus, if we pushed the<br />
concurrent connections even more, we may have seen more of a pronounced<br />
difference.</li>
  <li>The <em>absence</em> of any major red flags was itself a validation. The<br />
question we wanted answered coming into this experiment was “how close<br />
are we to maxing out our single-node EC2 configuration such that we will<br />
have to begin configuring horizontal scaling?”? The answer was: we can<br />
safely scale further out in the near-term future, and cross the bridge<br />
of horizontal scaling/bursting when we get there.</li>
  <li>We did not have enough statistically significant differences in<br />
performance for #threads/#processes in Puma. However, if we wanted to<br />
truly find the optimal performance in our app, we would have turned to<br />
tools like <a href="https://github.com/schneems/puma_auto_tune">puma_auto_tune</a> to answer those questions.</li>
</ul>

<p>Let me know in the comments if you have any questions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker, Rails, and Docker Compose in your development workflow]]></title>
    <link href="http://www.g9labs.com/2015/03/19/docker-rails-and-docker-compose-in-your-development-workflow/"/>
    <updated>2015-03-19T13:29:00-07:00</updated>
    <id>http://www.g9labs.com/2015/03/19/docker-rails-and-docker-compose-in-your-development-workflow</id>
    <content type="html"><![CDATA[<p>(This post <a href="http://blog.carbonfive.com/2015/03/17/docker-rails-docker-compose-together-in-your-development-workflow/">originally appeared</a> on the Carbon Five blog.)</p>

<p>We’ve been trialing the usage of Docker and <a href="https://docs.docker.com/compose/">Docker Compose</a> (previously known as <a href="http://www.fig.sh">fig</a>) on a Rails project here at Carbon Five. In the past, my personal experience with Docker had been that the promise of portable containerized apps was within reach, but the tooling and development workflow were still awkward - commands were complex, configuration and linking steps were complicated, and the overall learning curve was high.</p>

<p>My team decided to take a peek at the current landscape of Docker tools (primarily boot2docker and Docker Compose) and see how easily we could spin up a new app and integrate it into our development workflow on Mac OS X.</p>

<p>In the end, I’ve found my experience with Docker tools to be surprisingly pleasant; the tooling easily integrates with existing Rails development workflows with only a minor amount of performance overhead. Docker Compose offers a seamless way to build containers and orchestrate their dependencies, and helps lower the learning curve to build Dockerized applications. Read on to find out how we built ours.</p>

<h2 id="introduction-to-docker-compose-ne-fig">Introduction to docker-compose (née Fig).</h2>

<p>Docker Compose acts as a wrapper around Docker - it links your containers together and provides syntactic sugar around some complex container linking commands.</p>

<p>We liked Docker Compose for its ability to coordinate and spin up your entire application and dependencies with one command. In the past, frameworks like Vagrant were easy ways to generate a standard image for your development team to use and get started on. Docker Compose offers similar benefits of decoupling the app from the host environment, but also provides the container vehicle for the app to run in all environments - that is, the container you develop in will often be the same container that you deploy to production with.</p>

<p>Docker (with the orchestration tooling provided by Compose) provides us the ability to:</p>

<ul>
  <li>Upgrade versions of Ruby or Node (or whatever runtime your app requires) in production with far less infrastructure coordination than normally required.</li>
  <li>Reduce the number of moving parts in the deployment process. Instead of writing complex Puppet and Capistrano deployment scripts, our deployments will now center around moving images around and starting containers.</li>
  <li>Simplify developer onboarding by standardizing your team on the same machine images.</li>
</ul>

<p>In this example, we will run two Docker containers - a Rails container and a MySQL container - and rely on Compose to build, link, and run them.</p>

<h2 id="installing-boot2docker-docker-and-docker-compose">Installing boot2docker, Docker, and Docker Compose.</h2>

<p>Docker runs in a VirtualBox VM through an image called <code>boot2docker</code>. The reason we have to use <code>boot2docker</code> and VirtualBox is because the Mac OSX filesystem is not compatible with the type of filesystem required to support Docker. Hence, we must run our Docker containers within yet another virtual machine.</p>

<ol>
  <li>Download and install <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>.</li>
  <li>Now install boot2docker and Docker Compose.</li>
</ol>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ brew install boot2docker docker-compose
</pre></div>
</div>
</div>
<ol>
  <li>Initialize and start up boot2docker</li>
</ol>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ boot2docker init
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>$ boot2docker start
</pre></div>
</div>
</div>

<ol>
  <li>Configure your Docker host to point to your boot2docker image.</li>
</ol>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ $(boot2docker shellinit)
</pre></div>
</div>
</div>

<p>You’ll need to run this for every terminal session that invokes the <code>docker</code> or <code>docker-compose</code> command - better export this line into your <code>.zshrc</code> or <code>.bashrc</code>.</p>

<h2 id="creating-a-dockerfile">Creating a Dockerfile</h2>

<p>Let’s start by creating a Dockerfile for this app. This specifies the base dependencies for our Rails application. We will need:</p>

<ul>
  <li>Ruby 2.2 - for our Rails instance</li>
  <li>NodeJS and NPM - for installation of Karma, jshint, and other JS dependencies.</li>
  <li>MySQL client - for ActiveRecord tasks</li>
  <li>PhantomJS - for executing JS-based tests</li>
  <li>vim - for inspecting and editing files within our container</li>
</ul>

<p>Create a <code>Dockerfile</code> from within your Rails app directory.</p>

<pre><code>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential nodejs npm nodejs-legacy mysql-client vim
RUN npm install -g phantomjs

RUN mkdir /myapp

WORKDIR /tmp
COPY Gemfile Gemfile
COPY Gemfile.lock Gemfile.lock
RUN bundle install

ADD . /myapp
WORKDIR /myapp
RUN RAILS_ENV=production bundle exec rake assets:precompile --trace
CMD ["rails","server","-b","0.0.0.0"]
</code></pre>

<p>Let’s start by breaking this up line-by-line:</p>

<pre><code>FROM ruby:2.2.0
</code></pre>
<p>The <a href="https://docs.docker.com/reference/builder/#from"><code>FROM</code></a> directive specifies the <a href="https://registry.hub.docker.com/u/library/ruby/"><code>library/ruby</code> base image from Docker Hub</a>, and uses the <code>2.2.0</code> tag, which corresponds to the Ruby 2.2.0 runtime.</p>

<p>From here on, we are going to be executing commands that will build on this reference image.</p>

<pre><code>RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential nodejs npm nodejs-legacy mysql-client vim
RUN npm install -g phantomjs
</code></pre>

<p>Each <a href="https://docs.docker.com/reference/builder/#run"><code>RUN</code></a> command builds up the image, installing specific application dependencies and setting up the environment. Here we install our app dependencies both from <code>apt</code> and <code>npm</code>.</p>

<h3 id="an-aside-on-how-a-docker-image-is-built">An aside on how a Docker image is built</h3>

<p>One of the core concepts in Docker is the concept of “layers”. Docker runs on operating systems that support layering filesystems such as <code>aufs</code> or <code>btrfs</code>. Changes to the filesystem can be thought of as atomic operations that can be rolled forward or backwards.</p>

<p>This means that Docker can effectively store its images as snapshots of each other, much like Git commits. This also has implications as to how we can build up and cache copies of the container as we go along.</p>

<p>The Dockerfile can be thought of as a series of rolling incremental changes to a base image - each command builds on top of the line before. This allows Docker to quickly rebuild changes to the reference image by understanding which lines have changed - and not rebuild the image from scratch each time.</p>

<p>Keep these concepts in mind as we talk about speeding up your Docker build in the following section.</p>

<h3 id="fast-docker-builds-by-caching-your-gemfiles">Fast Docker builds by caching your Gemfiles</h3>

<p>The following steps install the required Ruby gems for Bundler, within your app container:</p>

<pre><code>WORKDIR /tmp
COPY Gemfile Gemfile
COPY Gemfile.lock Gemfile.lock
RUN bundle install
</code></pre>

<p>Note how we sneak the gems into <code>/tmp</code>, then run the <code>bundle install</code> which downloads and installs gems into Bundler’s <code>vendor/bundle</code> directory. This is a cache hack - whereas in the past we would have kept the <code>Gemfile</code>s in with the rest of the application directory in <code>/myapp</code>.</p>

<p>Keeping Gemfiles inline with the app would have meant that the entire <code>bundle install</code> command would have been re-run on each <code>docker-compose build</code> – without any caching – due to the constant change in the code in the <code>/myapp</code> directory.</p>

<p>By separating out the Gemfiles into their own directory, we logically separate the Gemfiles, which are far less likely to change, from the app code, which are far more likely to change. This reduces the number of times we have to wait for a clean <code>bundle install</code> to complete.</p>

<p>HT: <a href="http://ilikestuffblog.com/2014/01/06/how-to-skip-bundle-install-when-deploying-a-rails-app-to-docker/">Brian Morearty: “How to skip bundle install when deploying a Rails app to Docker”</a></p>

<h3 id="adding-the-app">Adding the app</h3>

<p>Finally, we finish our Dockerfile by adding our current app code to the working directory.</p>

<pre><code>ADD . /myapp
WORKDIR /myapp
RUN RAILS_ENV=production bundle exec rake assets:precompile --trace
CMD ["rails","server","-b","0.0.0.0"]
</code></pre>

<p>This links the contents of the app directory on the host to the  <code>/myapp</code> directory within the container.</p>

<p>Note that we precompile all our assets before the container boots up - this ensures that the container is preloaded and ready to run and jives with Docker tenets that a container should be the same container that runs in development, test, and production environments.</p>

<h2 id="setting-up-docker-compose">Setting up Docker Compose</h2>

<p>Now that we’ve defined a <code>Dockerfile</code> for booting our Rails app, we turn to the Compose piece that orchestrates the linking phase between the Rails app and its dependencies - in this case, the DB.</p>

<p>A <code>docker-compose.yml</code> file automatically configures our application ecosystem. Here, it defines our Rails container and its db container:</p>

<div class="language-yaml highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#606">web</span>:
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  <span style="color:#606">build</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">.</span></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  <span style="color:#606">volumes</span>:
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">.:/myapp</span></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  <span style="color:#606">ports</span>:
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">3000:3000</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  <span style="color:#606">links</span>:
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">db</span></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  <span style="color:#606">env_file</span>:
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">'.env.web'</span></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span><span style="color:#606">db</span>:
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  <span style="color:#606">image</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">library/mysql:5.6.22</span></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  <span style="color:#606">ports</span>:
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">13306:3306</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  <span style="color:#606">env_file</span>:
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">'.env.db'</span></span>
</pre></div>
</div>
</div>

<p>A simple:</p>

<pre><code>$ docker-compose up
</code></pre>

<p>will spin up both the <code>web</code> and <code>db</code> instances.</p>

<p>One of the most powerful tools of using Docker Compose is the ability to abstract away the configuration of your server, no matter whether it is running as a development container on your computer, a test container on CI, or on your production Docker host.</p>

<p>The directive:</p>

<div class="language-yaml highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#606">links</span>:
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">db</span></span>
</pre></div>
</div>
</div>

<p>will add an entry for <code>db</code> into the Rails’ container’s <code>/etc/hosts</code>, linking the hostname to the correct container. This allows us to write our database.yml like so:</p>

<div class="language-yaml highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#777"># config/database.yml</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span style="color:#606">development</span>: <span style="color:#037">&amp;default</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  <span style="color:#606">host</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">db</span></span>
</pre></div>
</div>
</div>

<p>Another important thing to note is the <code>volumes</code> configuration:</p>

<div class="language-yaml highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#777"># docker-compose.yml</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span style="color:#606">volumes</span>:
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">.:/myapp</span></span>
</pre></div>
</div>
</div>

<p>This mounts the current directory <code>.</code> on the host Mac to the <code>/myapp</code> directory in the container. This allows us to make live code changes on the host filesystem and see code changes reflected in the container.</p>

<p>Also note that we make use of Compose’s <code>env_file</code> directive, which allows us to specify environment variables to inject into the container at runtime:</p>

<div class="language-yaml highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#606">env_file</span>:
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  - <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#D20">'.env.web'</span></span>
</pre></div>
</div>
</div>

<p>A peek into <code>.env.web</code> shows:</p>

<pre><code>PORT=3000
PUMA_WORKERS=1
MIN_THREADS=4
MAX_THREADS=16
SECRET_KEY_BASE=&lt;Rails secret key&gt;
AWS_REGION=us-west-2
# ...
</code></pre>

<p>Note that the <code>env_file</code> is powerful in that it allows us to swap out environment configurations when you deploy and run your containers. Perhaps your container needs separate configurations on dev than when on CI, or when deployed to staging or on production.</p>

<h2 id="creating-containers-and-booting-them-up">Creating containers and booting them up.</h2>

<p>Now it’s time to assemble the container. From within the Rails app, run:</p>

<pre><code>$ docker-compose build
</code></pre>

<p>This downloads and builds the containers that your web app and your db will live in, linking them up. You will need to re-run the <code>docker-compose build</code> command every time you change the <code>Dockerfile</code> or <code>Gemfile</code>.</p>

<h2 id="running-your-app-in-containers">Running your app in containers</h2>

<p>You can bring up your Rails server and associated containers by running:</p>

<pre><code>$ docker-compose up
</code></pre>

<p>This is a combination of build, link, and start-services command for<br />
each container. You should see output that indicates that both our <code>web</code> and <code>db</code> containers, as configured in the <code>docker-compose.yml</code> file, are booting up.</p>

<h2 id="development-workflow">Development workflow</h2>

<p>I was pleasantly surprised to discover that developing with Docker added very little overhead to the development process. In fact, most commands that you would run for Rails simply needed to be prepended with a <code>docker-compose run web</code>.</p>

<table>
  <thead>
    <tr>
      <th>When you want to run:</th>
      <th>With Docker Compose, you would run:</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bundle install</code></td>
      <td><code>docker-compose run web bundle install</code></td>
    </tr>
    <tr>
      <td><code>rails s</code></td>
      <td><code>docker-compose run web rails s</code></td>
    </tr>
    <tr>
      <td><code>rspec spec/path/to/spec.rb</code></td>
      <td><code>docker-compose run web rspec spec/path/to/spec.rb</code></td>
    </tr>
    <tr>
      <td><code>RAILS_ENV=test rake db:create</code></td>
      <td><code>docker-compose run -e RAILS_ENV=test web rake db:create</code></td>
    </tr>
    <tr>
      <td><code>tail -f log/development.log</code></td>
      <td><code>docker-compose run web tail -f log/development.log</code></td>
    </tr>
  </tbody>
</table>

<h2 id="protips">Protips</h2>

<p>Here are some nice development tricks I found useful when working with Docker:</p>

<ul>
  <li>Add a <code>dockerhost</code> entry to your <code>/etc/hosts</code> file so you can visit <code>dockerhost</code> from your browser.</li>
</ul>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ boot2docker ip
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>192.168.59.104
</pre></div>
</div>
</div>

<p>Then add the IP to your <code>/etc/hosts</code></p>

<pre><code>192.168.59.104  dockerhost
</code></pre>

<p>Now you can pull up your app from <code>dockerhost:3000</code>:</p>

<p><img src="http://i.imgur.com/5eqNJqN.png" alt="Screenshot of your URL bar" /></p>

<ul>
  <li>
    <p>Debugging containers with <code>docker exec</code></p>

    <p>Sometimes you need to get inside a container to see what’s <em>really</em> happening. Perhaps you need to test whether a port is truly open, or verify that a process is truly running. This can be accomplished by grabbing the container ID with a <code>docker ps</code>, then passing that ID into the <code>docker exec</code> command:</p>
  </li>
</ul>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ docker ps
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>CONTAINER ID        IMAGE
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>301fa6331388        myrailsapp_web:latest
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>$ docker exec -it 301fa6331388 /bin/bash
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>root@301fa6331388:/myapp#
</pre></div>
</div>
</div>

<ul>
  <li>Showing environment variables in a container with <code>docker-compose run web env</code></li>
</ul>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ docker-compose run web env
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>AWS_SECRET_KEY=
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>MAX_THREADS=16
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>MIN_THREADS=4
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>AWS_REGION=us-west-2
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>BUNDLE_APP_CONFIG=/usr/local/bundle
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>HOME=/root
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>#...
</pre></div>
</div>
</div>

<ul>
  <li>
    <p>Running an interactive debugger (like <a href="http://pryrepl.org/">pry</a>) in your Docker container</p>

    <p>It takes a little extra work to get Docker to allow interactive terminal debugging with tools like <code>byebug</code> or <code>pry</code>. Should you desire to start your web server with debugging capabilities, you will need to use the <code>--service-ports</code> flag with the <code>run</code> command.</p>
  </li>
</ul>

<div class="language-bash highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>$ docker-compose run --service-ports web
</pre></div>
</div>
</div>

<p>This works due to two internal implementations of <code>docker-compose run</code>:</p>

<ul>
  <li><code>docker-compose run</code> creates a TTY session for your app to connect to, allowing interactive debugging. The default <code>docker-compose up</code> command does not create a TTY session.</li>
  <li>The <code>run</code> command does not map ports to the Docker host by default. The <code>--service-ports</code> directive maps the container’s ports to the host’s ports, allowing you to visit the container from your web browser.</li>
</ul>

<ol>
  <li>Use <code>slim</code> images when possible on production</li>
</ol>

<p>Oftentimes, your base image will come supplied with a <code>-slim</code> variant on Docker Hub. This usually means that the image maintainer has supplied a trimmed-down version of the container for you to use with source code and build-time files stripped and removed. You can oftentimes shave a couple hundred megabytes off your resulting image – we did when we switched our <code>ruby</code> image from <code>2.2.1</code> to <code>2.2.1-slim</code>. This results in faster deployment times due to less network I/O from the registry to the deployment target.</p>

<h2 id="gotchas">Gotchas</h2>

<ul>
  <li>
    <p>Remember that your app runs in containers - so every time you do a <code>docker-compose run</code>, remember that Compose is spinning up entirely new containers for your code <strong>but only if the containers are not up already, in which case they are linked to that (running) container</strong>.</p>

    <p>This means that it’s possible that you’ve spun up multiple instances of your app without thinking about it - for example, you may have a <code>web</code> and <code>db</code> container already up from a <code>docker-compose up</code> command, and then in a separate terminal window you run a <code>docker-compose run web rails c</code>. That spins up <em>another</em> <code>web</code> container to execute the command, but then links that container with the pre-launched <code>db</code> container.</p>
  </li>
  <li>
    <p>There is a small but noticeable performance penalty running through both the VirtualBox VM and docker. I’ve generally noticed waiting a few extra seconds when starting a Rails environment. My overall experience has been that the penalty has not been large enough to be painful.</p>
  </li>
</ul>

<h2 id="try-it-out">Try it out</h2>

<p>Give this a shot and let me know how Docker has been working for you. What have your experiences been? What are ways in which you’ve been able to get your Docker workflow smoother? Share in the comments below.</p>

<h3 id="coming-up-integration-with-ci-and-deployment">Coming up: integration with CI and deployment.</h3>

<p>In upcoming blog posts, we will investigate how to use the power of Docker Compose to test and build your containers in a CI-powered workflow, push to Docker registries, and deploy to production. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Data, Rails, CORS, and you!]]></title>
    <link href="http://www.g9labs.com/2013/12/27/ember-data-rails-cors-and-you/"/>
    <updated>2013-12-27T16:22:00-08:00</updated>
    <id>http://www.g9labs.com/2013/12/27/ember-data-rails-cors-and-you</id>
    <content type="html"><![CDATA[<p>I’m starting up a new personal project involving Ember-Data and Rails<br />
(more to come). The gist of it is that it’s a pure frontend app engine<br />
built in Yeoman and Grunt, and designed to talk to a remote API service<br />
built on Rails.</p>

<p>So since it’s a remote API, I’ve got to enable CORS, right?</p>

<h2 id="install-cors-via-rack-cors">Install CORS via rack-cors</h2>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#777"># Gemfile</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>gem <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rack-cors</span><span style="color:#710">&quot;</span></span>, <span style="color:#A60">:require</span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rack/cors</span><span style="color:#710">&quot;</span></span>
</pre></div>
</div>
</div>

<div class="language-ruby highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#777"># config/application.rb</span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>config.middleware.use <span style="color:#036;font-weight:bold">Rack</span>::<span style="color:#036;font-weight:bold">Cors</span> <span style="color:#080;font-weight:bold">do</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  allow <span style="color:#080;font-weight:bold">do</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    origins <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">*</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    resource <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">*</span><span style="color:#710">&quot;</span></span>,
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      <span style="color:#A60">:headers</span> =&gt; <span style="color:#A60">:any</span>,
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      <span style="color:#A60">:methods</span> =&gt; [<span style="color:#A60">:get</span>, <span style="color:#A60">:post</span>, <span style="color:#A60">:put</span>, <span style="color:#A60">:delete</span>, <span style="color:#A60">:options</span>, <span style="color:#A60">:patch</span>]
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  allow <span style="color:#080;font-weight:bold">do</span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    origins <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">*</span><span style="color:#710">&quot;</span></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    resource <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">/public/*</span><span style="color:#710">&quot;</span></span>,
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      <span style="color:#A60">:headers</span> =&gt; <span style="color:#A60">:any</span>,
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      <span style="color:#A60">:methods</span> =&gt; <span style="color:#A60">:get</span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  <span style="color:#080;font-weight:bold">end</span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span><span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>A very naive implementation with zero security whatsoever. Anyways.<br />
Onward!</p>

<h2 id="get-ember-data-dsrestadapter-talkin-cors">Get Ember-Data DS.RESTAdapter talkin’ CORS</h2>

<p>I saw conflicting documentation on Ember-Data and CORS – it seemed like<br />
it should support CORS out of the box. Apparently this is not so.</p>

<p>In my ember app’s <code>store.js</code> (or anywhere your app loads before the<br />
application adapter is defined, do this:</p>

<div class="language-javascript highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#F00;background-color:#FAA">#</span> store.js
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span style="color:#369;font-weight:bold">$</span>.ajaxSetup({
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  <span style="color:#606">crossDomain</span>: <span style="color:#069">true</span>,
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  <span style="color:#606">xhrFields</span>: {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    <span style="color:#606">withCredentials</span>: <span style="color:#069">true</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  }
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>});
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>Hendrix.Store = DS.Store.extend();
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>Hendrix.ApplicationAdapter = DS.RESTAdapter.extend({
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  <span style="color:#606">host</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://localhost:3000</span><span style="color:#710">&quot;</span></span>,
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>})
</pre></div>
</div>
</div>

<p><a href="http://api.jquery.com/jQuery.ajaxSetup/"><code>$.ajaxSetup</code></a>, though its<br />
usage is not recommended, is designed to set global options on the<br />
jQuery <code>ajax</code> object. It provides some information on the options you can modify.</p>

<p>Why doesn’t Ember support this out of the box? I think it’s because they<br />
cannot support IE, where one must use an XDR object to support CORS.</p>

<p>I’ve posted an <a href="http://discuss.emberjs.com/t/ember-data-and-cors/3690">Ember follow-up question in the<br />
forums</a> for discussion.</p>

<h2 id="get-rails-talking-json-out-of-its-mimetype-confusion">Get Rails talking JSON out of its mimetype confusion.</h2>

<p>Did you know that if you rely on the <code>Accepts:</code> header in HTTP that<br />
Rails does not obey its ordering<code>*</code>? I was trying to figure out why my<br />
Rails controllers were trying to render HTML instead of JSON when the<br />
headers were:</p>

<p><code>'Accept: application/json, text/javascript, */*; q=0.01'</code></p>

<p>A <a href="https://github.com/rails/rails/issues/9940">very long winded<br />
discussion</a> on the Rails<br />
project reveals that, well, nobody has it figured out yet. Most modern<br />
browsers do obey <code>Accepts:</code> specificity, but for the sake of older<br />
browser compatibility, the best practice for browsers is still to return<br />
HTML when <code>*/*</code> is specified.</p>

<p>What does this mean for Rails developers who want to use <code>Accepts:</code><br />
mimetype lists? Well, we either wait for the Rails projects to support<br />
mimetype specificity (and for older browsers to die out), or we are<br />
encouraged to include the format explicitly in the URI.</p>

<p>I chose to have Ember append the <code>.json</code> suffix to the URL, thanks to<br />
this <a href="http://stackoverflow.com/questions/13648807/ds-model-url-not-working-in-ember-js">SO<br />
post</a></p>

<div class="language-javascript highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#F00;background-color:#FAA">#</span> store.js
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>Hendrix.ApplicationAdapter = DS.RESTAdapter.extend({
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  <span style="color:#606">host</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://localhost:3000</span><span style="color:#710">&quot;</span></span>,
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  <span style="color:#777">// Force ember-data to append the `json` suffix</span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  <span style="color:#06B;font-weight:bold">buildURL</span>: <span style="color:#080;font-weight:bold">function</span>(record, suffix) {
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#950">this</span>._super(record, suffix) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.json</span><span style="color:#710">&quot;</span></span>;
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  }
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>})
</pre></div>
</div>
</div>

<p>More to come how how this app works.</p>
]]></content>
  </entry>
  
</feed>
