<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pub/sub | The Sweet Spot]]></title>
  <link href="http://www.g9labs.com/category/pub-slash-sub/atom.xml" rel="self"/>
  <link href="http://www.g9labs.com/"/>
  <updated>2016-06-24T11:07:28-07:00</updated>
  <id>http://www.g9labs.com/</id>
  <author>
    <name><![CDATA[Andrew Hao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evented Rails: Decoupling domains in Rails with Wisper pub/sub events]]></title>
    <link href="http://www.g9labs.com/2016/06/23/rails-pub-slash-sub-with-wisper-and-sidekiq/"/>
    <updated>2016-06-23T11:44:00-07:00</updated>
    <id>http://www.g9labs.com/2016/06/23/rails-pub-slash-sub-with-wisper-and-sidekiq</id>
    <content type="html"><![CDATA[<p>One common pattern in Domain-Driven Design is the use of
publish/subscribe messaging to communicate between domains. When
<a href="http://martinfowler.com/eaaDev/DomainEvent.html">Domain Events</a> are created from within a domain, other domains are
able to subscribe to these events and take action within their own
domains, respectively.</p>

<p>This is not a common pattern in Rails, particularly because of Ruby&rsquo;s
lack of language support for functional programming paradigms that exist
in other languages. However, with a nifty framework and the help of
Sidekiq, we can get just a little bit closer.</p>

<h3>What is a Domain Event?</h3>

<p>A domain event is a recorded property in the system that tracks an
action that the system performs, and the factors/properties that lead to
its creation.</p>

<p>In the following examples, we are going to use the <a href="https://github.com/krisleech/wisper">Wisper</a> gem to
implement domain events in our sample <a href="http://github.com/andrewhao/delorean">Delorean</a> app.</p>

<p>Imagine that we are writing an endpoint that our users will hit,
indicating that they want to hail a time-traveling cab. Now the logic to
hail a cab is rather complicated and lives in an entirely different area
of the codebase, perhaps even in another application. How should we call
the other code and ensure that our code is cleanly decoupled?</p>

<p>With our Domain-Driven powers, we&rsquo;ve been smart enough to segregate our code into different
subdomains and bounded contexts,
denoted by these two Ruby modules <code>Ridesharing</code> and <code>DriverRouting</code>.</p>

<h2>Example 1: In-process pub-sub event modeling, with a service object.</h2>

<p>A simple way to use Wisper is to use it to implement your service
objects with Wisper, calling the service from the controller.</p>

<p>```ruby
module Ridesharing
  class RidesController &lt; ApplicationController</p>

<pre><code>def post
  # Hail a time-traveling Delorean:
  command = HailDelorean.new
  command.on('hailed') { |driver|
    render text: "Hailed you a cab: #{driver} is arriving!"
  }
  .on('could_not_hail') {
    render text: "Sorry, no dice."
  }
  command.hail!(current_user)
end
</code></pre>

<p>  end
end
```</p>

<p>Note that the <code>HailDelorean</code> class has powers of event subscriptions
now. Our calling code does not have to concern itself with the
implementation details of the <code>HailDelorean</code> service &ndash; it merely needs
to register handlers for the two possible outcomes, <code>hailed</code> and
<code>could_not_hail</code>. Here&rsquo;s how the service class is implemented:</p>

<p>```ruby
module Ridesharing
  class HailDelorean</p>

<pre><code>include Wisper::Publisher

def hail!(user)
  # broadcast() is a Wisper method to fire an event
  driver = find_driver(user)
  if driver
    broadcast('hailed', driver)
  else
    broadcast('could_not_hail')
  end

def find_driver(user)
  # Here lies slow, complex domain logic
  DriverRouting::FindDriver.new(user)
end
</code></pre>

<p>  end
end
```</p>

<h3>Handling side effects in subscriber classes</h3>

<p>Other side-effects can subscribe to the <code>HailDelorean</code> events. Let&rsquo;s say we want to fire an event
to Segment analytics tracking. I can create a plain Ruby object that simply needs to implement a method with the same name as the event.</p>

<p>Let&rsquo;s implement <code>hailed</code> and <code>could_not_hail</code> methods on this subscriber class:</p>

<p>```ruby
class TrackSegmentAnalytics
  def self.hailed(driver)</p>

<pre><code># fire analytics event to Segment
</code></pre>

<p>  end</p>

<p>  def self.could_not_hail</p>

<pre><code># fire analytics event to Segment
</code></pre>

<p>  end
end
```</p>

<p>And we hook it up by subscribing it to the command handler:</p>

<p>```ruby
module Ridesharing
  class RidesController &lt; ApplicationController</p>

<pre><code>def post
  # snip
  command = HailDelorean.new(current_user)

  # register the subscriber to the triggering action
  command.subscribe(TrackSegmentAnalytics)
  # snip
end
</code></pre>

<p>  end
end
```</p>

<p>OK, that was a little awkward, doing all that wiring up in the controller. What if we did the wiring globally,
within an app initializer?</p>

<p>```ruby</p>

<h1>config/initializers/domain_event_subscriptions.rb</h1>

<p>Wisper.subscribe(TrackSegmentAnalytics, scope: &ldquo;HailDelorean&rdquo;)</p>

<h1>alternate form:</h1>

<p>HailDelorean.subscribe(TrackSegmentAnalytics)
```</p>

<p>This registers a global subscriber for all future instances of <code>HailDelorean</code>.</p>

<h2>Example 2: Asynchronous events with subscription handlers and Sidekiq</h2>

<p>Here&rsquo;s the real power of Wisper &ndash; we can decouple our application domain responsibilities by modeling
effects as subscription objects and do them out-of-band of the primary web request thread.</p>

<p>Note that with the <a href="https://github.com/krisleech/wisper-sidekiq"><code>wisper-sidekiq</code></a> gem, all subscriptions
given with an <code>async: true</code> option flag will automatically execute in an external thread as a Sidekiq job.
Let&rsquo;s take advantage of that now.</p>

<p>```ruby
module Ridesharing
  class RidesController &lt; ApplicationController</p>

<pre><code>def post
  # Hail a time-traveling Delorean:
  HailDelorean.hail(current_user.id)
  render text: 'Hailing a cab, please wait for a response...'
end
</code></pre>

<p>  end</p>

<p>  class HailDelorean</p>

<pre><code>include Wisper::Broadcaster

def self.hail(passenger_id)
  broadcast(:hail, passenger_id)
end
</code></pre>

<p>  end
end</p>

<p>module DriverRouting
  # Note that this class is both a subscriber and a publisher
  class FindDriver</p>

<pre><code>include Wisper::Publisher

def self.hail(passenger_id)
  # Do slow, complex hairy routefinding/optimization/messaging behind the scenes:
  driver = find_driver_for(passenger_id)

  if driver
    broadcast('driver_found', passenger_id, driver.id)
  else
    broadcast('driver_not_found', passenger_id)
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Finally, we add handlers (subscribers) to these domain objects:</p>

<p>```ruby
module Ridesharing
  class NotifyPassengerWithDriverStatus</p>

<pre><code>def self.driver_found
  # send them a text message :)
end

def self.driver_not_found
  # send them a text message :(
end
</code></pre>

<p>  end
end
```</p>

<p>Now let&rsquo;s link it together with subscriptions:</p>

<p>```ruby</p>

<h1>config/initializers/domain_event_subscriptions.rb</h1>

<p>Ridesharing::HailDelorean.subscribe(DriverRouting::FindDriver, async: true)
DriverRouting::FindDriver.subscribe(Ridesharing::NotifyPassengerWithDriverStatus, async: true)
Wisper.subscribe(AnalyticsListener, scope: &ldquo;Ridesharing::NotifyPassengerWithDriverStatus&rdquo;, &ldquo;DriverRouting::FindDriver&rdquo;], async: true)
```</p>

<p>Now our messages between our domains are pulled out of the main request thread, and operate in an asynchronous
fashion with Sidekiq as the runner.</p>

<p>Code in our domains are kept clean &ndash; note that there are no direct references to the other subdomains within each
subdomain. Our app more cleanly segregates the responsibilities between each app, heavy workloads are naturally
balanced as they move to worker threads.</p>

<h2>Caveats: Beware of overbuilding</h2>

<p>If you are on a small app, you probably should go with approach #1. The weight of indirection
can be a cognitive load on development, unless you truly need to build async code in #2. The overhead and
conceptual complexities of the approach can only be justified with large codebases, or in apps
where a domain-centric view (and segregation) of code is present.</p>

<h2>Caveats: Event subscriptions can be a tangled mess</h2>

<p>Note that the act of wiring can quickly fan out into a spidery mess of handlers &ndash; you could even further
decouple your handlers by modeling a global event bus as a publisher, and having each domain tap into the bus' events
and figure out how to handle each event on its own.</p>

<h2>Caveats: transactional consistency!</h2>

<p>If you implement this asynchronously, you&rsquo;ll have to think about how to
deal with transactional consistency. Can you design your data models
(and database schema) to support independent updates without any
dependencies? How will you handle
the case when one domain action fails and the other completes?</p>

<p>You may have to roll your own two-phase commit here, the specifics of
which I won&rsquo;t delve into. However, for most of our applications, we may
want to skip the asynchronous and keep our events synchronous.</p>
]]></content>
  </entry>
  
</feed>
