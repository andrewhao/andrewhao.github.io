
<!doctype html>
<!-- START OF _layouts/default.html -->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
		<meta content="width=device-width,initial-scale=1" name="viewport">
		<meta content="Andrew Hao's thoughts on software engineering, team leadership & product design." name="description">
		<meta content="The Sweet Spot" name="author">

		<title>Docker, Rails, and Docker Compose in your development workflow &mdash; The Sweet Spot</title>

		<!-- Styles -->
		<link href="/stylesheets/main.css" rel="stylesheet">

		<!-- Google webfonts -->
    <link href="https://fonts.googleapis.com/css?family=Cousine|Suez+One|Yellowtail|Space+Mono|Alike+Angular" rel="stylesheet">

		<!-- jQuery and plugins -->
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script src="/js/jquery.zclip.min.js"></script>

		<!-- Syntax highlighter -->
		<link href="/stylesheets/prettify-hemisu.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="/js/prettify.js"></script>

    <link href="" rel="alternate" title="The Sweet Spot" type="application/atom+xml">
    


  </head>

	<body onload="prettyPrint()">
		<div class="wrap">

			<header>
        <a href="/"><div class="title">The Sweet Spot</div></a>
				<div class="subtitle">On software, engineering leadership, and anything shiny.</div>

				<div class="navi">
					<ul>
						<li><a href="/">Articles</a></li>
						<li><a href="/talks">Talks</a></li>
						<li><a href="/notes">Conference Notes</a></li>
						<li><a href="https://www.github.com/andrewhao">Github</a></li>
						<li><a href="https://twitter.com/andrewhao">Twitter</a></li>
					</ul>
				</div> <!-- // .navi -->
			</header>

				<!-- START OF _layouts/post.html -->

<!-- START OF _includes/article.html -->
<article>
	<header>
		<h1><a href="/2015/03/19/docker-rails-and-docker-compose-in-your-development-workflow/">Docker, Rails, and Docker Compose in your development workflow</a></h1>
		<time>19 March 2015</time>
	</header>
		<div class="content">
			<p>(This post <a href="http://blog.carbonfive.com/2015/03/17/docker-rails-docker-compose-together-in-your-development-workflow/">originally appeared</a> on the Carbon Five blog.)</p>

<p>We’ve been trialing the usage of Docker and <a href="https://docs.docker.com/compose/">Docker Compose</a> (previously known as <a href="http://www.fig.sh">fig</a>) on a Rails project here at Carbon Five. In the past, my personal experience with Docker had been that the promise of portable containerized apps was within reach, but the tooling and development workflow were still awkward - commands were complex, configuration and linking steps were complicated, and the overall learning curve was high.</p>

<p>My team decided to take a peek at the current landscape of Docker tools (primarily boot2docker and Docker Compose) and see how easily we could spin up a new app and integrate it into our development workflow on Mac OS X.</p>

<p>In the end, I’ve found my experience with Docker tools to be surprisingly pleasant; the tooling easily integrates with existing Rails development workflows with only a minor amount of performance overhead. Docker Compose offers a seamless way to build containers and orchestrate their dependencies, and helps lower the learning curve to build Dockerized applications. Read on to find out how we built ours.</p>

<h2 id="introduction-to-docker-compose-née-fig">Introduction to docker-compose (née Fig).</h2>

<p>Docker Compose acts as a wrapper around Docker - it links your containers together and provides syntactic sugar around some complex container linking commands.</p>

<p>We liked Docker Compose for its ability to coordinate and spin up your entire application and dependencies with one command. In the past, frameworks like Vagrant were easy ways to generate a standard image for your development team to use and get started on. Docker Compose offers similar benefits of decoupling the app from the host environment, but also provides the container vehicle for the app to run in all environments - that is, the container you develop in will often be the same container that you deploy to production with.</p>

<p>Docker (with the orchestration tooling provided by Compose) provides us the ability to:</p>

<ul>
  <li>Upgrade versions of Ruby or Node (or whatever runtime your app requires) in production with far less infrastructure coordination than normally required.</li>
  <li>Reduce the number of moving parts in the deployment process. Instead of writing complex Puppet and Capistrano deployment scripts, our deployments will now center around moving images around and starting containers.</li>
  <li>Simplify developer onboarding by standardizing your team on the same machine images.</li>
</ul>

<p>In this example, we will run two Docker containers - a Rails container and a MySQL container - and rely on Compose to build, link, and run them.</p>

<h2 id="installing-boot2docker-docker-and-docker-compose">Installing boot2docker, Docker, and Docker Compose.</h2>

<p>Docker runs in a VirtualBox VM through an image called <code class="highlighter-rouge">boot2docker</code>. The reason we have to use <code class="highlighter-rouge">boot2docker</code> and VirtualBox is because the Mac OSX filesystem is not compatible with the type of filesystem required to support Docker. Hence, we must run our Docker containers within yet another virtual machine.</p>

<ol>
  <li>Download and install <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>.</li>
  <li>Now install boot2docker and Docker Compose.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>brew <span class="nb">install </span>boot2docker docker-compose
</code></pre></div></div>
<ol>
  <li>Initialize and start up boot2docker</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>boot2docker init
<span class="nv">$ </span>boot2docker start
</code></pre></div></div>

<ol>
  <li>Configure your Docker host to point to your boot2docker image.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="k">$(</span>boot2docker shellinit<span class="k">)</span>
</code></pre></div></div>

<p>You’ll need to run this for every terminal session that invokes the <code class="highlighter-rouge">docker</code> or <code class="highlighter-rouge">docker-compose</code> command - better export this line into your <code class="highlighter-rouge">.zshrc</code> or <code class="highlighter-rouge">.bashrc</code>.</p>

<h2 id="creating-a-dockerfile">Creating a Dockerfile</h2>

<p>Let’s start by creating a Dockerfile for this app. This specifies the base dependencies for our Rails application. We will need:</p>

<ul>
  <li>Ruby 2.2 - for our Rails instance</li>
  <li>NodeJS and NPM - for installation of Karma, jshint, and other JS dependencies.</li>
  <li>MySQL client - for ActiveRecord tasks</li>
  <li>PhantomJS - for executing JS-based tests</li>
  <li>vim - for inspecting and editing files within our container</li>
</ul>

<p>Create a <code class="highlighter-rouge">Dockerfile</code> from within your Rails app directory.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential nodejs npm nodejs-legacy mysql-client vim
RUN npm install -g phantomjs

RUN mkdir /myapp

WORKDIR /tmp
COPY Gemfile Gemfile
COPY Gemfile.lock Gemfile.lock
RUN bundle install

ADD . /myapp
WORKDIR /myapp
RUN RAILS_ENV=production bundle exec rake assets:precompile --trace
CMD ["rails","server","-b","0.0.0.0"]
</code></pre></div></div>

<p>Let’s start by breaking this up line-by-line:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ruby:2.2.0
</code></pre></div></div>
<p>The <a href="https://docs.docker.com/reference/builder/#from"><code class="highlighter-rouge">FROM</code></a> directive specifies the <a href="https://registry.hub.docker.com/u/library/ruby/"><code class="highlighter-rouge">library/ruby</code> base image from Docker Hub</a>, and uses the <code class="highlighter-rouge">2.2.0</code> tag, which corresponds to the Ruby 2.2.0 runtime.</p>

<p>From here on, we are going to be executing commands that will build on this reference image.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential nodejs npm nodejs-legacy mysql-client vim
RUN npm install -g phantomjs
</code></pre></div></div>

<p>Each <a href="https://docs.docker.com/reference/builder/#run"><code class="highlighter-rouge">RUN</code></a> command builds up the image, installing specific application dependencies and setting up the environment. Here we install our app dependencies both from <code class="highlighter-rouge">apt</code> and <code class="highlighter-rouge">npm</code>.</p>

<h3 id="an-aside-on-how-a-docker-image-is-built">An aside on how a Docker image is built</h3>

<p>One of the core concepts in Docker is the concept of “layers”. Docker runs on operating systems that support layering filesystems such as <code class="highlighter-rouge">aufs</code> or <code class="highlighter-rouge">btrfs</code>. Changes to the filesystem can be thought of as atomic operations that can be rolled forward or backwards.</p>

<p>This means that Docker can effectively store its images as snapshots of each other, much like Git commits. This also has implications as to how we can build up and cache copies of the container as we go along.</p>

<p>The Dockerfile can be thought of as a series of rolling incremental changes to a base image - each command builds on top of the line before. This allows Docker to quickly rebuild changes to the reference image by understanding which lines have changed - and not rebuild the image from scratch each time.</p>

<p>Keep these concepts in mind as we talk about speeding up your Docker build in the following section.</p>

<h3 id="fast-docker-builds-by-caching-your-gemfiles">Fast Docker builds by caching your Gemfiles</h3>

<p>The following steps install the required Ruby gems for Bundler, within your app container:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WORKDIR /tmp
COPY Gemfile Gemfile
COPY Gemfile.lock Gemfile.lock
RUN bundle install
</code></pre></div></div>

<p>Note how we sneak the gems into <code class="highlighter-rouge">/tmp</code>, then run the <code class="highlighter-rouge">bundle install</code> which downloads and installs gems into Bundler’s <code class="highlighter-rouge">vendor/bundle</code> directory. This is a cache hack - whereas in the past we would have kept the <code class="highlighter-rouge">Gemfile</code>s in with the rest of the application directory in <code class="highlighter-rouge">/myapp</code>.</p>

<p>Keeping Gemfiles inline with the app would have meant that the entire <code class="highlighter-rouge">bundle install</code> command would have been re-run on each <code class="highlighter-rouge">docker-compose build</code> – without any caching – due to the constant change in the code in the <code class="highlighter-rouge">/myapp</code> directory.</p>

<p>By separating out the Gemfiles into their own directory, we logically separate the Gemfiles, which are far less likely to change, from the app code, which are far more likely to change. This reduces the number of times we have to wait for a clean <code class="highlighter-rouge">bundle install</code> to complete.</p>

<p>HT: <a href="http://ilikestuffblog.com/2014/01/06/how-to-skip-bundle-install-when-deploying-a-rails-app-to-docker/">Brian Morearty: “How to skip bundle install when deploying a Rails app to Docker”</a></p>

<h3 id="adding-the-app">Adding the app</h3>

<p>Finally, we finish our Dockerfile by adding our current app code to the working directory.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADD . /myapp
WORKDIR /myapp
RUN RAILS_ENV=production bundle exec rake assets:precompile --trace
CMD ["rails","server","-b","0.0.0.0"]
</code></pre></div></div>

<p>This links the contents of the app directory on the host to the  <code class="highlighter-rouge">/myapp</code> directory within the container.</p>

<p>Note that we precompile all our assets before the container boots up - this ensures that the container is preloaded and ready to run and jives with Docker tenets that a container should be the same container that runs in development, test, and production environments.</p>

<h2 id="setting-up-docker-compose">Setting up Docker Compose</h2>

<p>Now that we’ve defined a <code class="highlighter-rouge">Dockerfile</code> for booting our Rails app, we turn to the Compose piece that orchestrates the linking phase between the Rails app and its dependencies - in this case, the DB.</p>

<p>A <code class="highlighter-rouge">docker-compose.yml</code> file automatically configures our application ecosystem. Here, it defines our Rails container and its db container:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">web</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
  <span class="na">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">.:/myapp</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:3000"</span>
  <span class="na">links</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">db</span>
  <span class="na">env_file</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s1">'</span><span class="s">.env.web'</span>
<span class="na">db</span><span class="pi">:</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">library/mysql:5.6.22</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">13306:3306"</span>
  <span class="na">env_file</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s1">'</span><span class="s">.env.db'</span>
</code></pre></div></div>

<p>A simple:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker-compose up
</code></pre></div></div>

<p>will spin up both the <code class="highlighter-rouge">web</code> and <code class="highlighter-rouge">db</code> instances.</p>

<p>One of the most powerful tools of using Docker Compose is the ability to abstract away the configuration of your server, no matter whether it is running as a development container on your computer, a test container on CI, or on your production Docker host.</p>

<p>The directive:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">links</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">db</span>
</code></pre></div></div>

<p>will add an entry for <code class="highlighter-rouge">db</code> into the Rails’ container’s <code class="highlighter-rouge">/etc/hosts</code>, linking the hostname to the correct container. This allows us to write our database.yml like so:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/database.yml</span>
<span class="na">development</span><span class="pi">:</span> <span class="nl">&amp;default</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">db</span>
</code></pre></div></div>

<p>Another important thing to note is the <code class="highlighter-rouge">volumes</code> configuration:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">.:/myapp</span>
</code></pre></div></div>

<p>This mounts the current directory <code class="highlighter-rouge">.</code> on the host Mac to the <code class="highlighter-rouge">/myapp</code> directory in the container. This allows us to make live code changes on the host filesystem and see code changes reflected in the container.</p>

<p>Also note that we make use of Compose’s <code class="highlighter-rouge">env_file</code> directive, which allows us to specify environment variables to inject into the container at runtime:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">env_file</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s1">'</span><span class="s">.env.web'</span>
</code></pre></div></div>

<p>A peek into <code class="highlighter-rouge">.env.web</code> shows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PORT=3000
PUMA_WORKERS=1
MIN_THREADS=4
MAX_THREADS=16
SECRET_KEY_BASE=&lt;Rails secret key&gt;
AWS_REGION=us-west-2
# ...
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">env_file</code> is powerful in that it allows us to swap out environment configurations when you deploy and run your containers. Perhaps your container needs separate configurations on dev than when on CI, or when deployed to staging or on production.</p>

<h2 id="creating-containers-and-booting-them-up">Creating containers and booting them up.</h2>

<p>Now it’s time to assemble the container. From within the Rails app, run:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker-compose build
</code></pre></div></div>

<p>This downloads and builds the containers that your web app and your db will live in, linking them up. You will need to re-run the <code class="highlighter-rouge">docker-compose build</code> command every time you change the <code class="highlighter-rouge">Dockerfile</code> or <code class="highlighter-rouge">Gemfile</code>.</p>

<h2 id="running-your-app-in-containers">Running your app in containers</h2>

<p>You can bring up your Rails server and associated containers by running:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker-compose up
</code></pre></div></div>

<p>This is a combination of build, link, and start-services command for
each container. You should see output that indicates that both our <code class="highlighter-rouge">web</code> and <code class="highlighter-rouge">db</code> containers, as configured in the <code class="highlighter-rouge">docker-compose.yml</code> file, are booting up.</p>

<h2 id="development-workflow">Development workflow</h2>

<p>I was pleasantly surprised to discover that developing with Docker added very little overhead to the development process. In fact, most commands that you would run for Rails simply needed to be prepended with a <code class="highlighter-rouge">docker-compose run web</code>.</p>

<table>
  <thead>
    <tr>
      <th>When you want to run:</th>
      <th>With Docker Compose, you would run:</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">bundle install</code></td>
      <td><code class="highlighter-rouge">docker-compose run web bundle install</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">rails s</code></td>
      <td><code class="highlighter-rouge">docker-compose run web rails s</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">rspec spec/path/to/spec.rb</code></td>
      <td><code class="highlighter-rouge">docker-compose run web rspec spec/path/to/spec.rb</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">RAILS_ENV=test rake db:create</code></td>
      <td><code class="highlighter-rouge">docker-compose run -e RAILS_ENV=test web rake db:create</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">tail -f log/development.log</code></td>
      <td><code class="highlighter-rouge">docker-compose run web tail -f log/development.log</code></td>
    </tr>
  </tbody>
</table>

<h2 id="protips">Protips</h2>

<p>Here are some nice development tricks I found useful when working with Docker:</p>

<ul>
  <li>Add a <code class="highlighter-rouge">dockerhost</code> entry to your <code class="highlighter-rouge">/etc/hosts</code> file so you can visit <code class="highlighter-rouge">dockerhost</code> from your browser.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>boot2docker ip
192.168.59.104
</code></pre></div></div>

<p>Then add the IP to your <code class="highlighter-rouge">/etc/hosts</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.59.104  dockerhost
</code></pre></div></div>

<p>Now you can pull up your app from <code class="highlighter-rouge">dockerhost:3000</code>:</p>

<p><img src="http://i.imgur.com/5eqNJqN.png" alt="Screenshot of your URL bar" /></p>

<ul>
  <li>
    <p>Debugging containers with <code class="highlighter-rouge">docker exec</code></p>

    <p>Sometimes you need to get inside a container to see what’s <em>really</em> happening. Perhaps you need to test whether a port is truly open, or verify that a process is truly running. This can be accomplished by grabbing the container ID with a <code class="highlighter-rouge">docker ps</code>, then passing that ID into the <code class="highlighter-rouge">docker exec</code> command:</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps
CONTAINER ID        IMAGE
301fa6331388        myrailsapp_web:latest
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> 301fa6331388 /bin/bash
root@301fa6331388:/myapp#
</code></pre></div></div>

<ul>
  <li>Showing environment variables in a container with <code class="highlighter-rouge">docker-compose run web env</code></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose run web <span class="nb">env
</span><span class="nv">AWS_SECRET_KEY</span><span class="o">=</span>
<span class="nv">MAX_THREADS</span><span class="o">=</span>16
<span class="nv">MIN_THREADS</span><span class="o">=</span>4
<span class="nv">AWS_REGION</span><span class="o">=</span>us-west-2
<span class="nv">BUNDLE_APP_CONFIG</span><span class="o">=</span>/usr/local/bundle
<span class="nv">HOME</span><span class="o">=</span>/root
<span class="c">#...</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Running an interactive debugger (like <a href="http://pryrepl.org/">pry</a>) in your Docker container</p>

    <p>It takes a little extra work to get Docker to allow interactive terminal debugging with tools like <code class="highlighter-rouge">byebug</code> or <code class="highlighter-rouge">pry</code>. Should you desire to start your web server with debugging capabilities, you will need to use the <code class="highlighter-rouge">--service-ports</code> flag with the <code class="highlighter-rouge">run</code> command.</p>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose run <span class="nt">--service-ports</span> web
</code></pre></div></div>

<p>This works due to two internal implementations of <code class="highlighter-rouge">docker-compose run</code>:</p>

<ul>
  <li><code class="highlighter-rouge">docker-compose run</code> creates a TTY session for your app to connect to, allowing interactive debugging. The default <code class="highlighter-rouge">docker-compose up</code> command does not create a TTY session.</li>
  <li>The <code class="highlighter-rouge">run</code> command does not map ports to the Docker host by default. The <code class="highlighter-rouge">--service-ports</code> directive maps the container’s ports to the host’s ports, allowing you to visit the container from your web browser.</li>
</ul>

<ol>
  <li>Use <code class="highlighter-rouge">slim</code> images when possible on production</li>
</ol>

<p>Oftentimes, your base image will come supplied with a <code class="highlighter-rouge">-slim</code> variant on Docker Hub. This usually means that the image maintainer has supplied a trimmed-down version of the container for you to use with source code and build-time files stripped and removed. You can oftentimes shave a couple hundred megabytes off your resulting image – we did when we switched our <code class="highlighter-rouge">ruby</code> image from <code class="highlighter-rouge">2.2.1</code> to <code class="highlighter-rouge">2.2.1-slim</code>. This results in faster deployment times due to less network I/O from the registry to the deployment target.</p>

<h2 id="gotchas">Gotchas</h2>

<ul>
  <li>
    <p>Remember that your app runs in containers - so every time you do a <code class="highlighter-rouge">docker-compose run</code>, remember that Compose is spinning up entirely new containers for your code <strong>but only if the containers are not up already, in which case they are linked to that (running) container</strong>.</p>

    <p>This means that it’s possible that you’ve spun up multiple instances of your app without thinking about it - for example, you may have a <code class="highlighter-rouge">web</code> and <code class="highlighter-rouge">db</code> container already up from a <code class="highlighter-rouge">docker-compose up</code> command, and then in a separate terminal window you run a <code class="highlighter-rouge">docker-compose run web rails c</code>. That spins up <em>another</em> <code class="highlighter-rouge">web</code> container to execute the command, but then links that container with the pre-launched <code class="highlighter-rouge">db</code> container.</p>
  </li>
  <li>
    <p>There is a small but noticeable performance penalty running through both the VirtualBox VM and docker. I’ve generally noticed waiting a few extra seconds when starting a Rails environment. My overall experience has been that the penalty has not been large enough to be painful.</p>
  </li>
</ul>

<h2 id="try-it-out">Try it out</h2>

<p>Give this a shot and let me know how Docker has been working for you. What have your experiences been? What are ways in which you’ve been able to get your Docker workflow smoother? Share in the comments below.</p>

<h3 id="coming-up-integration-with-ci-and-deployment">Coming up: integration with CI and deployment.</h3>

<p>In upcoming blog posts, we will investigate how to use the power of Docker Compose to test and build your containers in a CI-powered workflow, push to Docker registries, and deploy to production. Stay tuned!</p>

			
			
		</div>
	<footer>
		<div class="article__categories">
  Tagged under
  
  
  <a class="article__category" href="/category/docker">Docker</a>
  , 
  
  <a class="article__category" href="/category/rails">Rails</a>
  
  
</div>

	
	
	</footer>
	
</article>
<!-- END OF _includes/article.html -->


  <section class="comments">
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


<!-- END OF _/layouts/post.html -->


			<footer>
				Copyright &copy; 2018

	The Sweet Spot


				

<script type="text/javascript">
      var disqus_shortname = 'g9labs';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://localhost:4000/2015/03/19/docker-rails-and-docker-compose-in-your-development-workflow/';
        var disqus_url = 'http://localhost:4000/2015/03/19/docker-rails-and-docker-compose-in-your-development-workflow/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











			</footer>

		</div> <!-- // .wrap -->
  </body>

	<script>
		$(document).ready(function() {
			// Make images center
			$('p:has(img)').css('text-align', 'center');

			// Add the image's title attribute as a caption
			$('p:has(img)').append(function () {
				return '<div class="caption">' + ($('img', this).attr('title') || "") + '</div>';
			});

			// Prettify code
			$('code').addClass('prettyprint');
			$('pre code').addClass('linenums');

			// Copy to clipboard with button
			$('pre:has(code)').prepend(function(){
				return '<div class="clip-btn">copy to clipboard</div>';
      });

			$('.clip-btn').zclip({
				path:'/js/ZeroClipboard.swf',
				copy: $(this).next('code').text(),
				afterCopy: function(){
					$(this).replaceWith('<div class="clip-btn">copied!');
					}
			});
		});
	</script>
</html>
<!-- END OF _layouts/default.html -->
