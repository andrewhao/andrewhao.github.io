
<!doctype html>
<!-- START OF _layouts/default.html -->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" >
		<meta content="width=device-width,initial-scale=1" name="viewport">
		<meta content="Andrew Hao's thoughts on software engineering, team leadership & product design." name="description">
		<meta content="The Sweet Spot" name="author">

		<title>Rails, meet Phoenix: Migrating to Phoenix with Rails session sharing &mdash; The Sweet Spot</title>

		<!-- Styles -->
		<link href="/stylesheets/main.css" rel="stylesheet">

		<!-- Google webfonts -->
    <link href="https://fonts.googleapis.com/css?family=Cousine|Suez+One|Yellowtail|Space+Mono|Alike+Angular" rel="stylesheet">

		<!-- jQuery and plugins -->
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script src="/js/jquery.zclip.min.js"></script>

		<!-- Syntax highlighter -->
		<link href="/stylesheets/prettify-hemisu.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="/js/prettify.js"></script>

    <link href="" rel="alternate" title="The Sweet Spot" type="application/atom+xml">
    


  </head>

	<body onload="prettyPrint()">
		<div class="wrap">

			<header>
        <a href="/"><div class="title">The Sweet Spot</div></a>
				<div class="subtitle">On software, engineering leadership, and anything shiny.</div>

				<div class="navi">
					<ul>
						<li><a href="/">Articles</a></li>
						<li><a href="/talks">Talks</a></li>
						<li><a href="/notes">Conference Notes</a></li>
						<li><a href="https://www.github.com/andrewhao">Github</a></li>
						<li><a href="https://twitter.com/andrewhao">Twitter</a></li>
					</ul>
				</div> <!-- // .navi -->
			</header>

				<!-- START OF _layouts/post.html -->

<!-- START OF _includes/article.html -->
<article>
	<header>
		<h1><a href="/2016/06/24/migrating-to-phoenix-with-rails-session-sharing/">Rails, meet Phoenix: Migrating to Phoenix with Rails session sharing</a></h1>
		<time>24 June 2016</time>
	</header>
		<div class="content">
			<p>You’ve resolved to build your company’s Next Big Thing in Phoenix and Elixir. That’s great! You’re facing a problem though - all user authentication and access concerns are performed on your Rails system, and the work to reimplement this in Phoenix is significant.</p>

<p>Fortunately for you, there is a great Phoenix plug to share session data between Rails and Phoenix. If you pull this off, you’ll be able to build your new API on your Phoenix app, all while letting Rails handle user authentication and session management.</p>

<h3 id="before-we-begin">Before we begin</h3>
<p>In this scenario, you want to build out a new API in Phoenix that is consumed by your frontend single-page application, whose sessions are hosted on Rails. We’ll call the Rails app <code class="highlighter-rouge">rails_app</code> and your new Phoenix app <code class="highlighter-rouge">phoenix_app</code>.</p>

<p>Additionally, each app will use a different subdomain. The Rails app will be deployed at the <code class="highlighter-rouge">www.myapp.com</code> subdomain. The Phoenix app will be deployed at the <code class="highlighter-rouge">api.myapp.com</code> subdomain.</p>

<p>We are going to take <a href="https://github.com/cconstantin">Chris Constantin</a>’s excellent <a href="https://github.com/cconstantin/plug_rails_cookie_session_store"><code class="highlighter-rouge">PlugRailsCookieSessionStore</code></a> plug and integrate it into our Phoenix project. Both apps will be configured with identical cookie domains, encryption salts, signing salts, and security tokens.</p>

<p>In the examples that follow, I’ll be using the latest versions of each framework at the time of writing, Rails 4.2 and Phoenix 1.2.</p>

<h3 id="cookie-based-session-storage">Cookie-based session storage</h3>

<p>Our session data is stored on the client in a secure, encrypted, validated cookie. We won’t cover the basics of cookies here, but <a href="http://www.justinweiss.com/articles/how-rails-sessions-work/">you can read more about them here</a>.</p>

<p>Our approach will only work if your current Rails system utilizes cookie-based sessions. We will not cover the use case with a database-backed session store in SQL, Redis, or Memcache.</p>

<h3 id="step-1-configure-rails-accordingly">Step 1: Configure Rails accordingly</h3>

<h4 id="configure-the-cookie-store">Configure the cookie store</h4>

<p>Let’s set up your Rails app to use a JSON cookie storage format:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/initializer/session_store.rb</span>

<span class="c1"># Use cookie session storage in JSON format. Here, we scope the cookie to the root domain.</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">session_store</span> <span class="ss">:cookie_store</span><span class="p">,</span> <span class="ss">key: </span><span class="s1">'_rails_app_session'</span><span class="p">,</span> <span class="ss">domain: </span><span class="s2">".</span><span class="si">#{</span><span class="no">ENV</span><span class="p">[</span><span class="s1">'DOMAIN'</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">action_dispatch</span><span class="p">.</span><span class="nf">cookies_serializer</span> <span class="o">=</span> <span class="ss">:json</span>

<span class="c1"># These salts are optional, but it doesn't hurt to explicitly configure them the same between the two apps.</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">action_dispatch</span><span class="p">.</span><span class="nf">encrypted_cookie_salt</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'SESSION_ENCRYPTED_COOKIE_SALT'</span><span class="p">]</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">action_dispatch</span><span class="p">.</span><span class="nf">encrypted_signed_cookie_salt</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'SESSION_ENCRYPTED_SIGNED_COOKIE_SALT'</span><span class="p">]</span>

</code></pre></div></div>

<p>Your app may not be configured with a <code class="highlighter-rouge">SESSION_ENCRYPTED_COOKIE_SALT</code> and <code class="highlighter-rouge">SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</code>. You may generate a pair with any random values.</p>

<p><a href="http://nipperlabs.com/rails-secretkeybase">Some speculate</a> that Rails does not require the two salts by default because the <code class="highlighter-rouge">SECRET_KEY_BASE</code> is sufficiently long enough to not require a salt. In our example, we choose to supply them anyways to be explicit.</p>

<p>Another important value to note here is that we have chosen a key for our session cookie - <code class="highlighter-rouge">_rails_app_session</code>. This value will be the shared cookie key for both apps.</p>

<h3 id="step-2-configure-the-plug-for-phoenix">Step 2: Configure the plug for Phoenix</h3>

<p>Turning our attention to our Phoenix app, in the <code class="highlighter-rouge">mix.exs</code> file, add the library dependency:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># mix.exs</span>
<span class="k">defmodule</span> <span class="no">PhoenixApp</span>
  <span class="k">defp</span> <span class="n">deps</span> <span class="k">do</span>
    <span class="c1"># snip</span>
    <span class="p">{</span><span class="ss">:plug_rails_cookie_session_store</span><span class="p">,</span> <span class="sd">"</span><span class="s2">~&gt; 0.1"</span><span class="p">},</span>
    <span class="c1"># snip</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then run <code class="highlighter-rouge">mix deps.get</code> to fetch the new library.</p>

<p>Now in your <code class="highlighter-rouge">web/phoenix_app/endpoint.ex</code> file, remove the configuration for the existing session store and add the configuration for the Rails session store.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/phoenix_app/endpoint.ex</span>
<span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Endpoint</span> <span class="k">do</span>
  <span class="n">plug</span> <span class="no">Plug</span><span class="o">.</span><span class="no">Session</span><span class="p">,</span>
    <span class="c1"># Remove the original cookie store that comes with Phoenix, out of the box.</span>
    <span class="c1"># store: :cookie,</span>
    <span class="c1"># key: "_phoenix_app_key",</span>
    <span class="c1"># signing_salt: "M8emDP0h"</span>
    <span class="ss">store:</span> <span class="no">PlugRailsCookieSessionStore</span><span class="p">,</span>
    <span class="c1"># Decide on a shared key for your cookie. Oftentimes, this should</span>
    <span class="c1"># mirror your Rails app session key</span>
    <span class="ss">key:</span> <span class="sd">"</span><span class="s2">_rails_app_session"</span><span class="p">,</span>
    <span class="ss">secure:</span> <span class="no">true</span><span class="p">,</span>
    <span class="ss">encrypt:</span> <span class="no">true</span><span class="p">,</span>
    <span class="c1"># Specifies the matching rules on the hostname that this cookie will be valid for</span>
    <span class="ss">domain:</span> <span class="sd">"</span><span class="s2">.</span><span class="si">#{</span><span class="no">System</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="sd">"</span><span class="s2">DOMAIN"</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
    <span class="ss">signing_salt:</span> <span class="no">System</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="sd">"</span><span class="s2">SESSION_ENCRYPTED_SIGNED_COOKIE_SALT"</span><span class="p">),</span>
    <span class="ss">encryption_salt:</span> <span class="no">System</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="sd">"</span><span class="s2">SESSION_ENCRYPTED_COOKIE_SALT"</span><span class="p">),</span>
    <span class="ss">key_iterations:</span> <span class="m">1000</span><span class="p">,</span>
    <span class="ss">key_length:</span> <span class="m">64</span><span class="p">,</span>
    <span class="ss">key_digest:</span> <span class="ss">:sha</span><span class="p">,</span>
    <span class="c1"># Specify a JSON serializer to use on the session</span>
    <span class="ss">serializer:</span> <span class="no">Poison</span>
<span class="k">end</span>

</code></pre></div></div>

<p>We set a <code class="highlighter-rouge">DOMAIN</code> environment variable with the value
<code class="highlighter-rouge">myapp.com</code>. The goal is for these two apps to be able to be deployed at any subdomain that ends in <code class="highlighter-rouge">myapp.com</code>, and still be able to share the cookie.</p>

<p>The <code class="highlighter-rouge">secure</code> flag configures the app to send a secure cookie, which only is served over SSL HTTPS connections. It is highly recommended for your site; if you haven’t upgraded to SSL, you should do so now!</p>

<p>Our cookies are signed such that their origins are guaranteed to have been computed from our app(s). This is done for free with Rails (and Phoenix’s) session libraries. The signature is derived from the <code class="highlighter-rouge">secret_key_base</code> and <code class="highlighter-rouge">signing_salt</code>.</p>

<p>The <code class="highlighter-rouge">encrypt</code> flag encrypts the contents of the cookie’s value with an encryption key derived from <code class="highlighter-rouge">secret_key_base</code> and <code class="highlighter-rouge">encryption_salt</code>. This should always be set to <code class="highlighter-rouge">true</code>.</p>

<p><code class="highlighter-rouge">key_iterations</code>, <code class="highlighter-rouge">key_length</code> and <code class="highlighter-rouge">key_digest</code> are configurations that dictate how the signing and encryption keys are derived. These are <a href="https://github.com/rails/rails/blob/4-2-stable/railties/lib/rails/application.rb">configured to match Rails’ defaults</a> (see also: <a href="https://github.com/rails/rails/blob/4-2-stable/activesupport/lib/active_support/key_generator.rb">defaults</a>). Unless your Rails app has custom configurations for these values, you should leave them be.</p>

<h3 id="step-3-configure-both-apps-to-read-from-the-new-environment-variables">Step 3: Configure both apps to read from the new environment variables</h3>

<p>Be sure your development and production versions of your app are configured with identical values for <code class="highlighter-rouge">DOMAIN</code>, <code class="highlighter-rouge">SESSION_ENCRYPTED_COOKIE_SALT</code> and <code class="highlighter-rouge">SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</code>. You’ll want to make sure your production apps store identical key-value pairs.</p>

<h3 id="step-4-change-phoenix-controllers-to-verify-sessions-based-on-session-data">Step 4: Change Phoenix controllers to verify sessions based on session data.</h3>

<p>Now when the Phoenix app receives incoming requests, it can simply look up user session data in the session cookie to determine whether the user is logged in, and who that user is.</p>

<p>In this example, our Rails app implements user auth with Devise and Warden. We know that Warden stores the user ID and a segment of the password hash in the <code class="highlighter-rouge">warden.user.user.key</code> session variable.</p>

<p>Here’s what the raw session data looks like when the <code class="highlighter-rouge">PlugRailsCookieSessionStore</code> extracts it from the cookie:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">%{</span><span class="sd">"</span><span class="s2">_csrf_token"</span> <span class="o">=&gt;</span> <span class="sd">"</span><span class="s2">ELeSt4MBUINKi0STEBpslw3UevGZuVLUx5zGVP5NlQU="</span><span class="p">,</span>
  <span class="sd">"</span><span class="s2">session_id"</span> <span class="o">=&gt;</span> <span class="sd">"</span><span class="s2">17ec9b696fe76ba4a777d625e57f3521"</span><span class="p">,</span>
  <span class="sd">"</span><span class="s2">warden.user.user.key"</span> <span class="o">=&gt;</span> <span class="p">[[</span><span class="m">2</span><span class="p">],</span> <span class="sd">"</span><span class="s2">$2a$10$R/3NKl9KQViQxY8eoMCIp."</span><span class="p">]}</span>
</code></pre></div></div>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">SomeApiResourceController</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Web</span><span class="p">,</span> <span class="ss">:controller</span>

  <span class="k">def</span> <span class="n">index</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_params</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span> <span class="o">=</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

    <span class="n">conn</span>
    <span class="o">|&gt;</span> <span class="n">assign</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">render</span><span class="p">(</span><span class="sd">"</span><span class="s2">index.html"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">plug</span> <span class="ss">:verify_session</span>

  <span class="c1"># If we've found a user, then allow the request to continue.</span>
  <span class="c1"># Otherwise, halt the request and return a 401</span>
  <span class="k">defp</span> <span class="n">verify_session</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">case</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">conn</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">conn</span> <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="m">401</span><span class="p">,</span> <span class="sd">"</span><span class="s2">Unauthorized"</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">halt</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">defp</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># =&gt; The Warden user storage scheme: [user_id, password_hash_truncated]</span>
    <span class="c1"># [[1], "$2a$10$vnx35UTTJQURfqbM6srv3e"]</span>
    <span class="n">warden_key</span> <span class="o">=</span> <span class="n">conn</span> <span class="o">|&gt;</span> <span class="n">get_session</span><span class="p">(</span><span class="sd">"</span><span class="s2">warden.user.user.key"</span><span class="p">)</span>

    <span class="k">case</span> <span class="n">warden_key</span> <span class="k">do</span>
      <span class="p">[[</span><span class="n">user_id</span><span class="p">],</span> <span class="n">_</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span>
      <span class="n">_</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:not_found</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A very naive plug implementation simply renders a 401 if the session key is not found in the session, otherwise it allows the request through.</p>

<h3 id="step-5-move-session-concerns-into-its-own-module">Step 5: Move session concerns into its own module</h3>

<p>Let’s move session concerns around session parsing out of the controller into its own <code class="highlighter-rouge">Session</code> module. Additionally, we include two helpers, <code class="highlighter-rouge">current_user/1</code> and <code class="highlighter-rouge">logged_in?/1</code>.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># web/models/session.ex</span>
<span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Session</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Web</span><span class="p">,</span> <span class="ss">:controller</span>
  <span class="k">def</span> <span class="n">current_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># Our app's concept of a User is merely whatever is stored in the</span>
    <span class="c1"># Session key. In the future, we could then use this as the delegation</span>
    <span class="c1"># point to fetch more details about the user from a backend store.</span>
    <span class="k">case</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">user_id</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:not_found</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="no">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">logged_in?</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">!!current_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># =&gt; The Warden user storage scheme: [user_id, password_hash_truncated]</span>
    <span class="c1"># [[1], "$2a$10$vnx35UTTJQURfqbM6srv3e"]</span>
    <span class="n">warden_key</span> <span class="o">=</span> <span class="n">conn</span> <span class="o">|&gt;</span> <span class="n">get_session</span><span class="p">(</span><span class="sd">"</span><span class="s2">warden.user.user.key"</span><span class="p">)</span>

    <span class="k">case</span> <span class="n">warden_key</span> <span class="k">do</span>
      <span class="p">[[</span><span class="n">user_id</span><span class="p">],</span> <span class="n">_</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span>
      <span class="n">_</span> <span class="o">-&gt;</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:not_found</span><span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This leaves the controller looking skinnier, implementing only the Plug. Extracted methods are delegated to the new <code class="highlighter-rouge">Session</code> module.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">SomeApiResourceController</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Web</span><span class="p">,</span> <span class="ss">:controller</span>
  <span class="n">alias</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Session</span>

  <span class="k">def</span> <span class="n">index</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_params</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">inspect</span> <span class="n">conn</span><span class="o">.</span><span class="n">private</span><span class="o">.</span><span class="n">plug_session</span>
    <span class="n">user_id</span> <span class="o">=</span> <span class="no">Session</span><span class="o">.</span><span class="n">current_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

    <span class="n">conn</span>
    <span class="o">|&gt;</span> <span class="n">assign</span><span class="p">(</span><span class="ss">:user_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">render</span><span class="p">(</span><span class="sd">"</span><span class="s2">index.html"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">plug</span> <span class="ss">:verify_session</span>

  <span class="c1"># Future refinements could extract this into its own Plug file.</span>
  <span class="k">defp</span> <span class="n">verify_session</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">case</span> <span class="no">Session</span><span class="o">.</span><span class="n">logged_in?</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">false</span> <span class="o">-&gt;</span> <span class="n">conn</span> <span class="o">|&gt;</span> <span class="n">send_resp</span><span class="p">(</span><span class="m">401</span><span class="p">,</span> <span class="sd">"</span><span class="s2">Unauthorized"</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">halt</span>
      <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">conn</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, we implement some nice helpers for your APIs:</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># web/web.ex</span>

<span class="k">def</span> <span class="n">view</span> <span class="k">do</span>
  <span class="kn">quote</span> <span class="k">do</span>
    <span class="c1"># snip</span>
    <span class="kn">import</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Session</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This gives you the ability to call <code class="highlighter-rouge">logged_in?(@conn)</code> and <code class="highlighter-rouge">current_user(@conn)</code> from within your views, should you desire to.</p>

<h3 id="step-6-fetching-additional-information-from-the-backend">Step 6: Fetching additional information from the backend</h3>

<p>Let’s enhance our <code class="highlighter-rouge">Session</code> module with the capability to fetch additional information from another resource.</p>

<p>In this case, we’ll model a call an external User API to fetch extended data about the User, potentially with some sensitive information (that’s why we didn’t want to serialize it into the session).</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># web/models/user.ex</span>
<span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">User</span> <span class="k">do</span>
  <span class="c1"># Gets some user identity information like email, avatar image.</span>
  <span class="c1"># For this example, we'll use a random user generator.</span>
  <span class="c1">#</span>
  <span class="c1"># This example hits an API, but this could just as easily be something that hits</span>
  <span class="c1"># the database, or Redis, or some cache.</span>
  <span class="k">def</span> <span class="n">fetch</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">%{</span> <span class="ss">body:</span> <span class="n">body</span> <span class="p">}</span> <span class="o">=</span> <span class="no">HTTPotion</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sd">"</span><span class="s2">https://randomuser.me/api?seed=</span><span class="si">#{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="p">[</span><span class="n">result</span> <span class="o">|</span> <span class="n">_</span> <span class="p">]</span> <span class="o">=</span> <span class="n">body</span> <span class="o">|&gt;</span> <span class="no">Poison</span><span class="o">.</span><span class="n">decode!</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sd">"</span><span class="s2">results"</span><span class="p">)</span>
    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now our <code class="highlighter-rouge">Session</code> can be extended to return the proper <code class="highlighter-rouge">User</code>, which may provide more utility to us as we implement our Phoenix feature.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Session</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">Web</span><span class="p">,</span> <span class="ss">:controller</span>
  <span class="n">alias</span> <span class="no">PhoenixApp</span><span class="o">.</span><span class="no">User</span>

  <span class="k">def</span> <span class="n">current_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">case</span> <span class="n">load_user</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="k">do</span>
      <span class="c1"># Changed current_user/1 to now return a User or a nil.</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">user_id</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">user_id</span> <span class="o">|&gt;</span> <span class="no">User</span><span class="o">.</span><span class="n">fetch</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="ss">:not_found</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="no">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># snip</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="heres-the-two-apps-in-action">Here’s the two apps in action:</h4>

<p><img src="http://i.imgur.com/Vu72x7C.gif" alt="Flipping between the two apps, logged in and out." /></p>

<h3 id="heroku-deployment-gotchas">Heroku deployment gotchas</h3>

<p>If you are deploying this to Heroku with the popular <a href="git@github.com:HashNuke/heroku-buildpack-elixir.git">Heroku Elixir buildpack</a>, please be aware that adding or changing environment variables that are required at build time require that the new environment variables outlined here are added to your <code class="highlighter-rouge">elixir_buildpack.config</code> file in your repository.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># elixir_buildpack.config</span>
<span class="n">config_vars_to_export</span><span class="o">=</span><span class="p">(</span><span class="no">SECRET_KEY_BASE</span> <span class="no">SESSION_ENCRYPTED_COOKIE_SALT</span> <span class="no">SESSION_ENCRYPTED_SIGNED_COOKIE_SALT</span> <span class="no">DOMAIN</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="caveats-and-considerations">Caveats and considerations</h3>

<h4 id="csrf-incompatibilites">CSRF incompatibilites</h4>

<p>At the time of this writing, Phoenix and Rails overwrite each others’ session CSRF tokens with incompatible token schemes. This means that you are not able to make remote POST or PUT requests across the apps with CSRF protection turned on. Our current approach will work best with a read-only API, at the moment.</p>

<h4 id="be-judicious-about-what-you-store-in-a-cookie">Be judicious about what you store in a cookie</h4>

<p>Cookies themselves have their own strengths and drawbacks. We should note that you should be judicious about the amount of <a href="http://guides.rubyonrails.org/security.html#replay-attacks-for-cookiestore-sessions">data you store in a session</a> (hint: only the bare minimum, and nothing sensitive).</p>

<p>The OWASP guidelines also provide some <a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet">general security practices around cookie session storage</a>.</p>

<h4 id="moving-beyond-session-sharing">Moving beyond session sharing</h4>

<p>Even though this scheme may work in the short run, coupling our apps at this level in the long run will result in headaches as the apps are coupled to intricate session implementation details. If, in the long run, you wanted to continue scaling out your Phoenix app ecosystem, you may want to look into the following authentication patterns, both of which move your system toward a microservices architecture.</p>

<p>1) Develop an <a href="http://microservices.io/patterns/apigateway.html">API gateway</a> whose purpose is to be the browser’s buffer to your internal service architecture. This one gateway is responsible for identity access and control, decrypting session data and proxying requests to an umbrella of internal services (which may be Rails or Phoenix). Internal services may receive user identities in unencrypted form.</p>

<p>2) Consider implementing a <a href="https://jwt.io/">JWT token implementation</a> across your apps, in which <a href="https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/">all session and authorization claims are stored in the token itself, and encrypted in the client and server.</a>. This scheme may still rely on cookies (you may store the token in a cookie, or pass it around in an HTTP header). The benefits of this scheme is the ability for your app(s) to manage identity and authentication claims on their own without having to verify against a third party. Drawbacks of this scheme are <a href="http://blog.prevoty.com/does-jwt-put-your-web-app-at-risk">the difficulty around revoking or expiring sessions</a>.</p>

<p>Each of these approaches is not without overhead and complexity; be sure to do your homework before your proceed.</p>

<h3 id="conclusion">Conclusion</h3>

<p>That’s it! I hope I’ve illustrated a quick and easy way to get a working Phoenix app sharing sessions with Rails app(s), should you decide to prototype one in your existing system. I’ve also pushed up a <a href="https://github.com/andrewhao/sample-rails-phoenix-shared-sessions/">sample app if you want to cross-reference the code</a>. Good luck!</p>

			
			
		</div>
	<footer>
		<div class="article__categories">
  Tagged under
  
  
  <a class="article__category" href="/category/elixir">Elixir</a>
  , 
  
  <a class="article__category" href="/category/phoenix">Phoenix</a>
  , 
  
  <a class="article__category" href="/category/rails">Rails</a>
  
  
</div>

	
	
	</footer>
	
</article>
<!-- END OF _includes/article.html -->


  <section class="comments">
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


<!-- END OF _/layouts/post.html -->


			<footer>
				Copyright &copy; 2018

	The Sweet Spot


				

<script type="text/javascript">
      var disqus_shortname = 'g9labs';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://localhost:4000/2016/06/24/migrating-to-phoenix-with-rails-session-sharing/';
        var disqus_url = 'http://localhost:4000/2016/06/24/migrating-to-phoenix-with-rails-session-sharing/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











			</footer>

		</div> <!-- // .wrap -->
  </body>

	<script>
		$(document).ready(function() {
			// Make images center
			$('p:has(img)').css('text-align', 'center');

			// Add the image's title attribute as a caption
			$('p:has(img)').append(function () {
				return '<div class="caption">' + ($('img', this).attr('title') || "") + '</div>';
			});

			// Prettify code
			$('code').addClass('prettyprint');
			$('pre code').addClass('linenums');

			// Copy to clipboard with button
			$('pre:has(code)').prepend(function(){
				return '<div class="clip-btn">copy to clipboard</div>';
      });

			$('.clip-btn').zclip({
				path:'/js/ZeroClipboard.swf',
				copy: $(this).next('code').text(),
				afterCopy: function(){
					$(this).replaceWith('<div class="clip-btn">copied!');
					}
			});
		});
	</script>
</html>
<!-- END OF _layouts/default.html -->
